<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>十七</title>
  
  <subtitle>愿时光能缓，愿你笑靥如花💖</subtitle>
  <link href="https://lcl.shiqi217.com/atom.xml" rel="self"/>
  
  <link href="https://lcl.shiqi217.com/"/>
  <updated>2022-11-06T13:57:27.172Z</updated>
  <id>https://lcl.shiqi217.com/</id>
  
  <author>
    <name>十七</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript中改变this指向的三种方法</title>
    <link href="https://lcl.shiqi217.com/2022/09/23/%E5%89%8D%E7%AB%AF/JS%E4%B8%AD%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://lcl.shiqi217.com/2022/09/23/%E5%89%8D%E7%AB%AF/JS%E4%B8%AD%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</id>
    <published>2022-09-22T20:02:17.000Z</published>
    <updated>2022-11-06T13:57:27.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-改变this指向的三种方法"><a href="#JavaScript-改变this指向的三种方法" class="headerlink" title="JavaScript-改变this指向的三种方法"></a>JavaScript-改变this指向的三种方法</h2><h4 id="一、this指向"><a href="#一、this指向" class="headerlink" title="一、this指向"></a>一、this指向</h4><p>this随处可见，一般谁调用，this就指向谁。this在不同环境下，不同作用下，表现的也不同。<br>以下几种情况，this都是指向window</p><h5 id="1、全局作用下，this指向的是window"><a href="#1、全局作用下，this指向的是window" class="headerlink" title="1、全局作用下，this指向的是window"></a>1、全局作用下，this指向的是window</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>===<span class="variable language_">this</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h5 id="2、函数独立调用时，函数内部的this也指向window"><a href="#2、函数独立调用时，函数内部的this也指向window" class="headerlink" title="2、函数独立调用时，函数内部的this也指向window"></a>2、函数独立调用时，函数内部的this也指向window</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是函数体&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);<span class="comment">//Window</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fun</span>();</span><br></pre></td></tr></table></figure><h5 id="3、被嵌套的函数独立调用时，this默认指向了window"><a href="#3、被嵌套的函数独立调用时，this默认指向了window" class="headerlink" title="3、被嵌套的函数独立调用时，this默认指向了window"></a>3、被嵌套的函数独立调用时，this默认指向了window</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">fun2</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是嵌套函数&#x27;</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// window</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">fun2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fun1</span>();</span><br></pre></td></tr></table></figure><h5 id="4、自调执行函数-立即执行-中内部的this也是指向window"><a href="#4、自调执行函数-立即执行-中内部的this也是指向window" class="headerlink" title="4、自调执行函数(立即执行)中内部的this也是指向window"></a>4、自调执行函数(立即执行)中内部的this也是指向window</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;立即执行&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// Window</span></span><br><span class="line">    &#125;)()</span><br></pre></td></tr></table></figure><h5 id="需要额外注意的是"><a href="#需要额外注意的是" class="headerlink" title="需要额外注意的是:"></a>需要额外注意的是:</h5><p>构造函数中的<code>this</code>，用于给类定义成员(属性和方法)</p><p>箭头函数中没有<code>this</code>指向，如果在箭头函数中有，则会向上一层函数中查找<code>this</code>，直到 <code>window</code></p><h4 id="二、改变this指向"><a href="#二、改变this指向" class="headerlink" title="二、改变this指向"></a>二、改变this指向</h4><h5 id="1、call-方法"><a href="#1、call-方法" class="headerlink" title="1、call() 方法"></a>1、call() 方法</h5><p>​    <code>call()</code>方法的第一个参数必须是指定的对象，然后方法的原参数，挨个放在后面。</p><p>​    (1)第一个参数:传入该函数this执行的对象，传入什么强制指向什么;</p><p>​    (2)第二个参数开始:将原函数的参数往后顺延一位</p><p>​            用法:  <code>函数名.call()</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 原来的函数this指向的是 window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a , b);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);<span class="comment">//this指向了输入的对象obj</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a : <span class="number">5</span>,</span><br><span class="line">    b : <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用call()方法改变this指向，此时第一个参数是对象obj，那么就会指向对象obj</span></span><br><span class="line">fun.<span class="title function_">call</span>(obj, <span class="number">5</span>, <span class="number">6</span>);  <span class="comment">//后面的参数就是原来函数自带的实参</span></span><br></pre></td></tr></table></figure><h5 id="2、apply-方法"><a href="#2、apply-方法" class="headerlink" title="2、apply()方法"></a>2、apply()方法</h5><p><code>apply()</code>方法的第一个参数是指定的对象，方法的原参数，统一放在第二个数组参数中。</p><p>(1)第一个参数:  传入该函数<code>this</code>执行的对象，传入什么强制指向什么</p><p>(2)第二个参数开始:  将原函数的参数放在一个数组中</p><p>​        用法:  <code>函数名.apply()</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">a , b</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(a , b);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);<span class="comment">//this指向了输入的字符串apply</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">fun</span>();</span><br><span class="line">        <span class="comment">//使用apply()方法改变this指向，此时第一个参数是字符串apply，那么就会指向字符串apply</span></span><br><span class="line">        fun.<span class="title function_">apply</span>(<span class="string">&#x27;apply&#x27;</span>, [<span class="number">2</span>,<span class="number">3</span>]);  <span class="comment">//原函数的参数要以数组的形式呈现</span></span><br></pre></td></tr></table></figure><h5 id="3、bind-方法"><a href="#3、bind-方法" class="headerlink" title="3、bind() 方法"></a>3、bind() 方法</h5><p><code>bind()</code>方法的用法和<code>call()</code>一样，直接运行方法，需要注意的是:  <code>bind</code>返回新的方法，需要重新调用</p><p>是需要自己手动调用的</p><p>​        用法:   <code>函数名.bind()</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);  <span class="comment">//this指向了输入的字符串bind</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用bind()方法改变this指向，此时第一个参数是字符串bind，那么就会指向字符串bind</span></span><br><span class="line">    <span class="keyword">let</span> c = fun.<span class="title function_">bind</span>(<span class="string">&#x27;bind&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="title function_">c</span>();  <span class="comment">//返回新的方法，需要重新调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以使用下面两种方法进行调用</span></span><br><span class="line">    <span class="comment">// fun.bind(&#x27;bind&#x27;, 2, 3)();</span></span><br><span class="line">    <span class="comment">// fun.bind(&#x27;bind)(2, 3);</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JavaScript-改变this指向的三种方法&quot;&gt;&lt;a href=&quot;#JavaScript-改变this指向的三种方法&quot; class=&quot;headerlink&quot; title=&quot;JavaScript-改变this指向的三种方法&quot;&gt;&lt;/a&gt;JavaScript-改变t</summary>
      
    
    
    
    <category term="前端" scheme="https://lcl.shiqi217.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JS" scheme="https://lcl.shiqi217.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Vue3知识点</title>
    <link href="https://lcl.shiqi217.com/2022/09/18/%E5%89%8D%E7%AB%AF/Vue%E7%9F%A5%E8%AF%86%E7%82%B9/Vue3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://lcl.shiqi217.com/2022/09/18/%E5%89%8D%E7%AB%AF/Vue%E7%9F%A5%E8%AF%86%E7%82%B9/Vue3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2022-09-18T11:50:17.000Z</published>
    <updated>2022-11-06T14:01:42.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、创建Vue3-0工程"><a href="#一、创建Vue3-0工程" class="headerlink" title="一、创建Vue3.0工程"></a>一、创建Vue3.0工程</h2><h4 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上 </span><br><span class="line">vue--version</span><br><span class="line">##安装或者升级你的@vue/cli </span><br><span class="line">npm install -g @vue/cli</span><br><span class="line">## 创建</span><br><span class="line">vue create vue test</span><br><span class="line">## 启动</span><br><span class="line">cd vue_test </span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><h4 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h4><p>官方文档:  <a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a><br>vite官网:  <a href="https://vitejs.cn">https://vitejs.cn</a><br>        什么是vite?—新一代前端构建工具。<br>                优势如下:<br>                    开发环境中，无需打包操作，可快速的冷启动。</p><p>​                    轻量快速的热重载(HMR)。</p><p>​                    真正的按需编译，不再等待整个应用编译完成。</p><p>​        传统构建与vite构建对比图</p><p><img src="/img/Vue/构建图.png" alt=" 传统构建与 vite 构建对比图"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">## 创建工程</span><br><span class="line">npm init vite-app&lt;project-name&gt;</span><br><span class="line">## 进入工程目录 </span><br><span class="line">cd &lt;project-name&gt;</span><br><span class="line">## 安装依赖 </span><br><span class="line">npm install</span><br><span class="line">## 运行</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h2 id="二、常用Composition-API"><a href="#二、常用Composition-API" class="headerlink" title="二、常用Composition API"></a>二、常用Composition API</h2><p><a href='https://v3cn.vuejs.org/quide/composition-api-introduction.html'>官方文档</a></p><h4 id="1-拉开序幕的setup"><a href="#1-拉开序幕的setup" class="headerlink" title="1.拉开序幕的setup"></a>1.拉开序幕的setup</h4><p>​    1.理解:Vue3.0中一个新的配置项，值为一个函数。</p><p>​    2.setup是所有<strong>Composition API (组合API)</strong>  “表演的舞台”</p><p>​    3.组件中所用到的:数据、方法等等，均要配置在setup中。</p><p>​    4.setup函数的两种返回值:</p><p>​            1.若返回一个对象，则对象中的属性、方法，在模板中均可以直接使用。(重点关注!！)</p><p>​            2.若返回一个渲染函数:则可以自定义渲染内容。(了解)</p><p>​    5.注意点:</p><p>​            1.尽量不要与Vue2.x配置混用</p><p>​                    Vue2.x配置(data.methoscomputed…)中可以访问到setup中的属性，方法。</p><p>​                    但在setup中不能访问到Vue2x配置(datamethoscomputed…)</p><p>​                    如果有重名，setup优先。</p><p>​            2.setup不能是一个async函数，因为返回值不再是return的对象，而是promise模板看不到return对象中的属性。</p><p>​            注意！！：如果<strong>用了Suspense</strong>并且还是<strong>动态引入</strong>(异步引入)的 配合</p><p>​                                <code>setup</code>也可以返回一个Promise实例，</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> &lt;<span class="title class_">Suspense</span>&gt;</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Child</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:fallback</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>加载中......<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">    &lt;/<span class="title class_">Suspense</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// import Child from &quot;@/components/Child&quot;;//静态引入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//异步引入(动态引入)</span></span><br><span class="line"><span class="keyword">import</span> &#123;defineAsyncComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./components/Child&#x27;</span>)) </span><br></pre></td></tr></table></figure><h4 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2.ref函数"></a>2.ref函数</h4><p>​        作用:定义一个响应式的数据</p><p>​        语法: <code>const xxx = ref(initValue)</code></p><p>​                    创建一个包含响应式数据的<strong>引用对象(reference对象 , 简称ref对象)</strong>。</p><p>​                    JS中操作数据: <code>xxx.value</code> </p><p>​                    模板中读取数据:不需要value，直接:<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></p><p>·        备注:</p><p>​                    接收的数据可以是:基本类型、也可以是对象类型。</p><p>​                    基本类型的数据:响应式依然是靠<code>ObjectdefineProperty()</code>的<code>get</code>与<code>set</code>完成的。</p><p>​                    对象类型的数据:内部“求助”了Vue3.0中的一个新函数—<code>reactive</code>函数。</p><h4 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3. reactive函数"></a>3. reactive函数</h4><p>​        作用:  定义一个<strong>对象类型</strong>的响应式数据(基本类型不要用它，用<code>ref</code>函数)</p><p>​        语法:   <code>const代理对象=reactive(源对象)</code>接收一个对象(或数组)，返回一个<strong>代理器对象(Proxy的实例对象，简称proxy对象)</strong> </p><p>​    reactive定义的响应式数据是“深层次的”。</p><p>​    内部基于ES6的Proxy实现，通过代理对象操作源对象内部数据进行操作</p><h4 id="4-Vue30中的响应式原理"><a href="#4-Vue30中的响应式原理" class="headerlink" title="4 Vue30中的响应式原理"></a>4 Vue30中的响应式原理</h4><h5 id="vue2x的响应式"><a href="#vue2x的响应式" class="headerlink" title="vue2x的响应式"></a>vue2x的响应式</h5><p>​    实现原理:<br>​            对象类型:通过0bject.defineProperty()对对象的已有属性值的读取、修改进行拦截(数据劫持)。</p><p>​            数组类型:通过重写更新数组的一系列方法来实现拦截。(对数组的变更方法进行了包裹)。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">0bject.<span class="title function_">defineProperty</span>(data,<span class="string">&#x27;count&quot;,&#123;</span></span><br><span class="line"><span class="string">get () &#123;&#125;, </span></span><br><span class="line"><span class="string">set() &#123;&#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><p>​    存在问题:</p><p>​                新增属性、删除属性，界面不会更新。</p><p>​                直接通过下标修改数组，界面不会自动更新。</p><h5 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h5><p>​        实现原理:<br>​                通过Proxy(代理): 拦截对象中任意属性的变化包括:属性值的读写、属性的添加、属性的删除等。</p><p>​                通过Refiect(反射): 对源对象的属性进行操作。</p><p>​                MDN文档中描述的Proxy与Reflect:<br>                    <a href='https://developer.mozilla.org/zh-CN/docsWeb/JavaScript/Reference/Global_Objects/Proxy'>Proxy</a></p><pre><code>                &lt;a href=&#39;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect&#39;&gt;Reflect&lt;/a&gt;new Proxy(data,&#123;    // 拦截读取属性值    get(target, prop)&#123;        return Reflect.get(target, prop)        &#125;，        //拦截设置属性值或添加新属性         set (target, prop, value) &#123;            return Reflect.set(target, prop,value)        &#125;，        // 拦截删除属性        deleteProperty(target，prop)&#123;            return Reflect.deleteProperty(target, prop)        &#125;&#125;)proxy.name =&#39;tom&#39;</code></pre><h4 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h4><p>​        从定义数据角度对比:</p><p>​                ref用来定义:  <strong>基本类型数据。</strong></p><p>​                reactive用来定义:  <strong>对象(或数组)类型数据</strong>。</p><p>​                备注: ref他可以用来定义<strong>对象(或数组)类型数据</strong>，它内部会自动通过<code>reactive</code>转为代理对象。</p><p>​        从原理角度对比:</p><p>​                ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式 (数据劫持)。</p><p>​                reactive通过使用<strong>Proxy</strong>来实现响应式 (数据劫持)，并通过<strong>Reflect</strong>操作<strong>源对象</strong>内部的数据。</p><p>​        从使用角度对比:</p><p>​                ref定义的数据:  操作数据<strong>需要</strong><code>.value</code>，读取数据时模板中直接读取<strong>不需要</strong><code>.value</code></p><p>​                reactive定义的数据:  操作数据与读取数据:<strong>均不需要</strong><code>.value</code>。</p><h4 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h4><p>​        setup执行的时机：</p><p>​                在beforeCreate之前执行一次，this是<code>undefined</code></p><p>​        setup的参数</p><p>​                props:  值为对象，包含 : 组件外部传递过来，且组件内部声明接收了的属性。</p><p>​                context:  上下文对象</p><p>​                            attrs:  值为对象，包含:组件外部传递过来，但没有在props配置中声明的属性，相当于<code>this.$attrs</code></p><p>​                            slots:  收到的插槽内容，相当于<code>this.$slots</code></p><p>​                            emit:  分发自定义事件的函数，相当于<code>this.$emit</code></p><h4 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h4><h5 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a><strong>1.computed函数</strong></h5><p>​            与Vue2x中computed配置功能一致</p><p>​            写法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;computed&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">..</span><br><span class="line"><span class="comment">//计算属性-简写</span></span><br><span class="line"><span class="keyword">let</span> fullName=<span class="title function_">computed</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> person.<span class="property">firstName</span>+<span class="string">&#x27;_&#x27;</span>+ person.<span class="property">lastName</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//计算属性一完整</span></span><br><span class="line"><span class="keyword">let</span> fullName=<span class="title function_">computed</span>(&#123;</span><br><span class="line"><span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> person.<span class="property">firstName</span>+<span class="string">&#x27;-&#x27;</span>+person.<span class="property">lastName</span></span><br><span class="line">&#125;，</span><br><span class="line"><span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line"><span class="keyword">const</span> nameArr =value.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>) </span><br><span class="line">person.<span class="property">firstName</span>=nameArr[<span class="number">0</span>] </span><br><span class="line">person.<span class="property">lastName</span>=nameArr[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h5><p>​    与Vue2.x中watch配置功能一致    注意：Vue3中的<strong>watch</strong>可以写<strong>无数个</strong></p><p>​    两个小“坑”:</p><p>​            监视reactive定义的响应式数据时:<strong>oldValue</strong>无法正确获取、强制开启了深度监视(deep配置失效)。</p><p>​            监视reactive定义的响应式数据中某个属性时:deep配置有效。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况一:监视ref定义的响应式数据 </span></span><br><span class="line"><span class="title function_">watch</span>(sum,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum变化了&quot;，newValue,oldValue)</span></span><br><span class="line"><span class="string">&#125;，&#123;immediate:true&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//情况二:监视多个ref定义的响应式数据</span></span><br><span class="line"><span class="string">watch([sum,msg],(newValue,oldValue)=&gt;&#123;</span></span><br><span class="line"><span class="string">console.log(&#x27;</span>sum或msg变化了<span class="string">&#x27;，newValueoldValue)</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* 情况三:监视reactive定义的响应式数据  *******</span></span><br><span class="line"><span class="string">若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue!!</span></span><br><span class="line"><span class="string">若watch监视的是reactive定义的响应式数据，则强制开启了深度监视</span></span><br><span class="line"><span class="string">*/</span></span><br><span class="line"><span class="string">watch(person,(newValue,oldValue)=&gt;&#123;</span></span><br><span class="line"><span class="string">console.log(person变化了&#x27;</span>，newValueoldValue)</span><br><span class="line">&#125;，&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">false</span>&#125;)<span class="comment">//此处的deep配置不再奏效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况四:监视reactive定义的响应式数据中的某个属性 </span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>，newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况五：监视reactive所定义的一个响应式数据中的  某些属性</span></span><br><span class="line"><span class="title function_">watch</span>([<span class="function">()=&gt;</span>person.<span class="property">age</span>,<span class="function">()=&gt;</span>person.<span class="property">name</span>],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的age和name变化了&#x27;</span>,newValue,oldValue);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊情况</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue);</span><br><span class="line">&#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;)<span class="comment">//此处由于监视的是reactive所定义的对象中的某个属性，所以deep配置有效</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3、watchEffect函数"><a href="#3、watchEffect函数" class="headerlink" title="3、watchEffect函数"></a>3、watchEffect函数</h5><p>​        watch的套路是: 既要指明监视的属性，也要指明监视的回调。</p><p>​        watchEffect的套路是:不用指明监视哪个属性，监视的回调中<strong>用到哪个属性</strong>，那就<strong>监视哪个属性</strong>。</p><p>​        watchEffect有点像computed:</p><p>​                    但computed注重的计算出来的值(回调函数的返回值)，所以必须要写返回值。</p><p>​                    而watchEffect更注重的是过程(回调函数的函数体)，所以不用写返回值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。 </span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">const</span> x1=sum.<span class="property">value</span> </span><br><span class="line"><span class="keyword">const</span> x2=person.<span class="property">age</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;watchEffect配置的回调执行了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h4><p><img src="/img/Vue/Vue2与Vue3对比.png" alt="Vue2与Vue3对比" style="zoom:80%;" /><br><img src="/img/Vue/生命周期.png" style="zoom: 33%;" /></p><p>Vue3.0中可以继续使用Vue2x中的生命周期钩子，但有有两个被更名:</p><p>​        <code>beforeDestroy</code>改名为<code>beforeUnmount</code></p><p>​        <code>destroyed</code>改名为<code>unmounted</code></p><p>Vue3.0也提供了CompositionAPI形式的生命周期钩子，与Vue2.x中钩子对应关系如下:</p><p>​        <code>beforeCreate</code>===&gt;<code>setup()</code></p><p>​        <code>created</code>=======&gt;<code>setup()</code></p><p>​        <code>beforeMount</code>===&gt;<code>onBeforeMount</code></p><p>​        <code>mounted</code>=======&gt; <code>onMounted</code></p><p>​        <code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></p><p>​        <code>updated</code>  ===&gt; <code>onUpdated</code> </p><p>​        <code>beforeUnmount</code>==&gt;<code>onBeforeUnmount</code></p><p>​        <code>unmounted</code>=====&gt;<code>onUnmounted</code></p><h4 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h4><p>​    什么是hook?—本质是一个函数，把setup函数中使用的CompositionAPI进行了封装。</p><p>​    类似于vue2x中的mixin。</p><p>​    自定义hook的优势复用代码，让setup中的逻辑更清楚易懂。</p><h2 id="10-toRef与toRefs"><a href="#10-toRef与toRefs" class="headerlink" title="10.toRef与toRefs"></a>10.toRef与toRefs</h2><p>​    作用:创建一个ref对象，其value值指向另一个对象中的某个属性值。</p><p>​    语法: <code>const name =toRef(person,&#39;name&#39;)</code> </p><p>​    应用:要将响应式对象中的某个属性单独提供给外部使用时。</p><p>​    扩展: <code>toRefs</code>与<code>toRef</code>功能一致，但可以批量创建多个ref对象，语法: <code>toRefs(person)</code></p><h2 id="三、其它Composition-API"><a href="#三、其它Composition-API" class="headerlink" title="三、其它Composition API"></a>三、其它Composition API</h2><h4 id="1、shallowReactive与shallowRef"><a href="#1、shallowReactive与shallowRef" class="headerlink" title="1、shallowReactive与shallowRef"></a>1、shallowReactive与shallowRef</h4><p>​            shallowReactive:   只处理对象最外层属性的响应式(浅响应式)。就是第一层的，里面的不响应</p><p>​            shallowRef:   只处理基本数据类型的响应式不进行对象的响应式处理。</p><p>​            什么时候使用?</p><p>​                        如果有一个对象数据，结构比较深，但变化时只是外层属性变化===&gt;shallowReactive</p><p>​                        如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换===&gt;shallowRef</p><h4 id="2-readonly与shallowReadonly"><a href="#2-readonly与shallowReadonly" class="headerlink" title="2.readonly与shallowReadonly"></a>2.readonly与shallowReadonly</h4><p>​    readonly:  让一个响应式数据变为只读的  (深只读)。就是<strong>全部</strong>都是只读的</p><p>​    shallowReadonly:  让一个响应式数据变为只读的  (浅只读)。就是<strong>第一层</strong>是只读的，更深层的还是可以修改</p><p>​    应用场景:  不希望数据被修改时。</p><p>​    </p><h4 id="3-toRaw与markRaw"><a href="#3-toRaw与markRaw" class="headerlink" title="3.toRaw与markRaw"></a>3.toRaw与markRaw</h4><p>​    toRaw:<br>​            作用:   将一个由<code>reactive</code>生成的<strong>响应式对象</strong>转为<strong>普通对象</strong>。ref不行</p><p>​            使用场景:  用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</p><p>​    markRaw:</p><p>​            作用:标记一个对象，使其<strong>永远不会</strong>再成为响应式对象。</p><p>​            应用场景:</p><p>​                    1.    有些值不应被设置为响应式的，例如复杂的第三方类库等。</p><p>​                    2.    当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能</p><h4 id="4customRef"><a href="#4customRef" class="headerlink" title="4customRef"></a>4customRef</h4><p>​        作用:   创建一个自定义的ref，并对其依赖项跟踪和更新触发进行显式控制</p><p>​        实现防抖效果:</p><p>​            </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;keyword&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;keyword&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span> </span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;ref,customRef&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;Demo&#x27;</span>, </span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">// let keyword=ref(&quot;hello)//使用Vue准备好的内置ref</span></span><br><span class="line"><span class="comment">//自定义一个myRef</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myRef</span>(<span class="params">value,delay</span>)&#123;</span><br><span class="line"><span class="keyword">let</span> timer</span><br><span class="line"><span class="comment">//通过customRef去实现自定义</span></span><br><span class="line"><span class="keyword">return</span> <span class="title function_">customRef</span>(<span class="function">(<span class="params">track,trigger</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span>&#123;</span><br><span class="line"><span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">track</span>()<span class="comment">//告诉Vue这个value值是需要被“追踪”的 </span></span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">set</span>(<span class="params">newValue</span>)&#123;</span><br><span class="line"><span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">timer=<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">value = newValue</span><br><span class="line"><span class="title function_">trigger</span>()<span class="comment">//告诉Vue去更新界面</span></span><br><span class="line">&#125;,delay)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let keyWord = ref(&#x27;hello&#x27;) //使用Vue提供的ref</span></span><br><span class="line">    <span class="keyword">let</span> keyWord = <span class="title function_">myRef</span>(<span class="string">&#x27;hello&#x27;</span>,<span class="number">100</span>) <span class="comment">//使用程序员自定义的ref</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> &#123;keyWord&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h4><p>​    <img src="/img/Vue/provide与inject.png" alt="provide与inject"></p><p>​        作用:  实现<strong>祖与后代组件间</strong>通信  (跨级组件通信)</p><p>​        套路:   父组件有一个<code>provide</code>选项来提供数据，后代组件有一个<code>inject</code>选项来开始使用这些数据</p><p>​        具体写法:<br>​                1.祖组件中:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">let</span> car =<span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;奔驰&#x27;</span>，<span class="attr">price</span>:<span class="string">&#x27;40万&#x27;</span>&#125;) </span><br><span class="line"><span class="title function_">provide</span>(<span class="string">&#x27;car&#x27;</span>,car)</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.后代组件中:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params">props,context</span>)&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">const</span> car = <span class="title function_">inject</span>(<span class="string">&#x27;car&#x27;</span>) </span><br><span class="line"><span class="keyword">return</span> &#123;car&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h4><p>​        isRef:    检查一个值是否为一个ref对象</p><p>​        isReactive:   检查一个对象是否是由<code>reactive</code>创建的响应式代理</p><p>​        isReadonly:   检查一个对象是否是由<code>readonly</code>创建的只读代理</p><p>​        isProxy:   检查一个对象是否是由<code>reactive</code>或者<code>readonly</code>方法创建的代理</p><h2 id="四、Composition-API的优势"><a href="#四、Composition-API的优势" class="headerlink" title="四、Composition API的优势"></a>四、Composition API的优势</h2><h4 id="1-OptionsAPI存在的问题"><a href="#1-OptionsAPI存在的问题" class="headerlink" title="1.OptionsAPI存在的问题"></a>1.OptionsAPI存在的问题</h4><p>​                    使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改。</p><p><img src="/img/Vue/Options API问题.gif"  /></p><p><img src="/img/Vue/Composition API 的优势.gif" alt=""></p><h4 id="2-CompositionAPI的优势"><a href="#2-CompositionAPI的优势" class="headerlink" title="2.CompositionAPI的优势"></a>2.CompositionAPI的优势</h4><p>​    我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><p><img src="/img/Vue/Composition API 的优势11.gif" alt=""></p><p><img src="/img/Vue/Composition API 的优势333.gif" alt=""></p><h2 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h2><h4 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h4><p>​            在Vue2中:组件必须有一个根标签</p><p>​            在Vue3中:组件可以没有根标签，内部会将多个标签包含在一个Fragment虚拟元素中</p><p>​            好处:   减少标签层级，减小内存占用</p><h4 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h4><p>​        什么是Teleport? ——<strong><code>Teleport</code></strong>是一种能够将我们的<strong>组件html结构</strong>移动到指定位置的技术</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;teleport to=<span class="string">&quot;移动位置&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span> <span class="attr">class</span>=<span class="string">&quot;mask&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dialog&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是一个弹窗<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;isShow=false&quot;</span>&gt;</span>关闭弹窗<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure><h4 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h4><p>​        等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p><p>​        使用步骤:</p><p>​                异步引入组件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineAsyncComponent&#125; <span class="keyword">from</span><span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> =<span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="title function_">import</span>(<span class="string">&#x27;./components/Child.vue&#x27;</span>))</span><br></pre></td></tr></table></figure><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code>(默认展示的)与<code>fallback</code>(加载慢了展示的)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是App组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">templatev-slot:default</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Child</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:fallback</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>加载中.....<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h2><h4 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h4><p>​    Vue2.x有许多全局API和配置。</p><p>​    例如:  注册全局组件、注册全局指令等。//注册全局组件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyButton&#x27;</span>,&#123; </span><br><span class="line"><span class="attr">data</span>:<span class="function">()=&gt;</span>(&#123; </span><br><span class="line"><span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">&#125;)，</span><br><span class="line"><span class="attr">template</span>:<span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//注册全局指令</span></span><br><span class="line"><span class="string">Vue.directive(&#x27;</span>focus<span class="string">&#x27;,&#123;</span></span><br><span class="line"><span class="string">inserted:el =&gt; el.focus()</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><p>​    Vue3.0中对这些API做出了调整:</p><p>​            将全局的API，即:  <code>Vue.xxx</code>调整到应用实例(<code>app</code>)上</p><div class="table-container"><table><thead><tr><th>2x全局API(<code>Vue</code>)</th><th>3x实例API(app)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong>移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></div><h4 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h4><p>​        data选项应始终被声明为一个函数。</p><p>​        过度类名的更改:<br>​                 Vue2.x写法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">v</span>-enter,</span><br><span class="line">.<span class="property">v</span>-leave-to&#123; </span><br><span class="line"><span class="attr">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">v</span>-leave,</span><br><span class="line">.<span class="property">v</span>-enter-to&#123; </span><br><span class="line"><span class="attr">opacity</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue3.x写法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.<span class="property">v</span>-enter-<span class="keyword">from</span>,</span><br><span class="line">.<span class="property">v</span>-leave-to&#123; </span><br><span class="line"><span class="attr">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.<span class="property">v</span>-leave-<span class="keyword">from</span>,</span><br><span class="line">.<span class="property">v</span>-enter-to&#123; </span><br><span class="line"><span class="attr">opacity</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>移除</strong> keyCode作为v-on的修饰符，同时也不再支持<code>config.keyCodes</code><br><strong>移除</strong> <code>v-on.native</code>修饰符</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">父组件中绑定事件</span><br><span class="line">&lt;my-component</span><br><span class="line">v-<span class="attr">on</span>:close=<span class="string">&quot;handleComponentEvent&#x27; </span></span><br><span class="line"><span class="string">v-on:click=&quot;</span>handleNativeClickEvent<span class="string">&quot;</span></span><br><span class="line"><span class="string">/&gt;</span></span><br></pre></td></tr></table></figure><p>子组件中声明自定义事件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; </span><br><span class="line"><span class="attr">emits</span>:[<span class="string">&#x27;close&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>移除</strong>过滤器 (filter)</p><p>​    过滤器虽然这看起来很方便，</p><p>​    但它需要一个自定义语法，打破大括号内表达式是“只是JavaScript”的假设，</p><p>​    这不仅有学习成本，而且有实现成本!  建议用方法(<code>computed</code>)调用或计算属性(<code>computed</code>)去替换过滤器。</p><p>……..</p>]]></content>
    
    
    <summary type="html">Vue3自己总结的初级知识点</summary>
    
    
    
    <category term="前端" scheme="https://lcl.shiqi217.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Vue" scheme="https://lcl.shiqi217.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的数组常用方法</title>
    <link href="https://lcl.shiqi217.com/2022/09/07/%E5%89%8D%E7%AB%AF/js%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://lcl.shiqi217.com/2022/09/07/%E5%89%8D%E7%AB%AF/js%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2022-09-07T08:02:17.000Z</published>
    <updated>2022-11-06T13:57:11.910Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数组常用方法总结"><a href="#数组常用方法总结" class="headerlink" title="数组常用方法总结"></a>数组常用方法总结</h4><pre><code>    01_数组常用方法      =&gt; 数组基础方法      =&gt; push() 在尾部追加      =&gt; pop()  删除最后一个数据      =&gt; unshift() 最前面插入数据      =&gt; shift()  删除最前面的数据    02_数组常用方法      =&gt; ES3.0, IE 6 7 8 可以是使用      =&gt; reverse()  反转数组      =&gt; sort()     数组排序      =&gt; splice()   1.截取数组，2.替换新内容      =&gt; join()        把每一个数据用连接符连接起来      =&gt; slice()    获取数组中的某些数据      =&gt; concat()   如果参数是数组, 那么把数组拆开, 里面每一项追加到原数组后面                      如果参数数数据, 那么直接追加    03_数组常用方法      ES5.0, IE 6 7 8 不好使了      =&gt; indexOf()      正向查看数组里面指定这个数据的索引      =&gt; lastIndexOf()  反向查看数组里面指定这个数据得索引      =&gt; forEach()        取代 for 循环得作用, 遍历数组      =&gt; map()            映射数组      =&gt; fliter()        过滤原始数组中得数据, 把满足条件得放在新数组里面      =&gt; every()        判断原始数组里面是不是每一个都满足条件(true/false)      =&gt; some()            判断数组中是不是有某一个满足条件(true/false)    04_数组常用方法      ES2015(ES6) 以后, 标准浏览器, IE 10 以上      =&gt; fill()            使用指定数据区填充数组      =&gt; copyWithin()    使用数组里面得内容替换数组里面得内容      =&gt; includes()        查看数组中是不是有某一个数据      =&gt; flat()            拍平数组      =&gt; flatMap()        拍平数组, 但是只能拍一层      =&gt; find()            根据条件找到数组里面满足条件得数据      =&gt; findIndex()    根据条件找到数组里面满足条件得数据</code></pre><h2 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h2><pre><code>就是 JS 自带一些操作数组得方法 常用方法得使用格式, 必须是 数组.xxx()    + 数组和伪数组得区别      =&gt; length 和 索引都一样, 循环遍历都一样      =&gt; 长得也一样      =&gt; 唯独数组常用方法, 伪数组同不了</code></pre><h4 id="1-push"><a href="#1-push" class="headerlink" title="1. push()"></a>1. push()</h4><p>   ​    =&gt; 语法: 数组.push(数据1, 数据2, 数据3, …)<br>   ​    =&gt; 作用: 把所有得参数按照顺序追加到数组得末尾位置<br>   ​    =&gt; 返回值: 追加以后数组得长度<br>   ​    =&gt; 直接操作原始数组</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;你好&#x27;, &#x27;世界&#x27;]</span><br><span class="line">   var res = arr.push(&#x27;新来的&#x27;, &#x27;新来的2&#x27;, [10, 20])</span><br><span class="line">   console.log(res)</span><br><span class="line">   console.log(arr)</span><br></pre></td></tr></table></figure><h4 id="2-pop"><a href="#2-pop" class="headerlink" title="2. pop()"></a>2. pop()</h4><p>   ​    =&gt; 语法: 数组.pop()<br>   ​    =&gt; 作用: 删除数组得最后一个数据<br>   ​    =&gt; 返回值: 被删除得数据<br>   ​    =&gt; 直接操作原始数组</p>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;你好&#x27;, &#x27;世界&#x27;]</span><br><span class="line">    var res = arr.pop()</span><br><span class="line">    console.log(res)</span><br><span class="line">    console.log(arr)</span><br></pre></td></tr></table></figure><h4 id="3-unshift"><a href="#3-unshift" class="headerlink" title="3. unshift()"></a>3. unshift()</h4><p>   ​    =&gt; 语法: 数组.unshift(数据1, 数据2, 数据3, …)<br>   ​    =&gt; 作用: 从数组得最前面插入一些数据<br>   ​    =&gt; 返回值: 插入后得数组长度<br>   ​    =&gt; 直接操作原始数组</p>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;你好&#x27;, &#x27;世界&#x27;]</span><br><span class="line">    var res = arr.unshift(&#x27;新来的&#x27;, &#x27;新来的2&#x27;)</span><br><span class="line">    console.log(res)</span><br><span class="line">    console.log(arr)</span><br></pre></td></tr></table></figure><h4 id="4-shift"><a href="#4-shift" class="headerlink" title="4. shift()"></a>4. shift()</h4><p>   ​    =&gt; 语法: 数组.shift()<br>   ​    =&gt; 作用: 删除数组得最前面一个数据<br>   ​    =&gt; 返回值: 被删除得数据<br>   ​    =&gt; 直接操作原始数组</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;你好&#x27;, &#x27;世界&#x27;]</span><br><span class="line">    var res = arr.shift()</span><br><span class="line">    console.log(res)</span><br><span class="line">    console.log(arr)</span><br></pre></td></tr></table></figure><h4 id="5-reverse"><a href="#5-reverse" class="headerlink" title="5. reverse()"></a>5. reverse()</h4><p>   ​    =&gt; 语法: 数组.reverse()<br>   ​    =&gt; 作用: 反转数组<br>   ​    =&gt; 返回值: 反转后得数组<br>   ​    =&gt; 直接操作原始数组</p>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;你好&#x27;, &#x27;世界&#x27;]</span><br><span class="line">   var res = arr.reverse()</span><br><span class="line">   console.log(res)</span><br><span class="line">   console.log(arr)</span><br></pre></td></tr></table></figure><h4 id="6-sort"><a href="#6-sort" class="headerlink" title="6. sort()"></a>6. sort()</h4><pre><code>    =&gt; 语法:      1. arr.sort()         -&gt; 按照每一个数据中得每一位数据得 ASCII 码进行排列      2. arr.sort(function (a, b) &#123; return a - b &#125;)         -&gt; 升序排列      3. arr.sort(function (a, b) &#123; return b - a &#125;)         -&gt; 降序排列    =&gt; 作用: 数组排序    =&gt; 返回值: 排序后得数组    =&gt; 直接操作原始数组   var arr = [1, 11, 33, 26, 51, 19, 32, 27, 15, 100]       var res = arr.sort()       console.log(res)       console.log(arr)   var res = arr.sort(function (a, b) &#123; return a - b &#125;)       console.log(res)       console.log(arr)   var res = arr.sort(function (a, b) &#123; return b - a &#125;)       console.log(res)       console.log(arr)</code></pre><h4 id="7-splice"><a href="#7-splice" class="headerlink" title="7. splice()"></a>7. splice()</h4><pre><code>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=&gt; 语法:</span><br><span class="line">1.数组.splice(开始索引, 多少个)</span><br><span class="line">-&gt; 从开始索引, 截取多少个</span><br><span class="line">-&gt; 第二个参数可以不写, 直接到末尾</span><br><span class="line">2.数组.splice(开始索引, 多少个, 替换数据1, 替换数据2, 替换数据3, ...)</span><br><span class="line">-&gt; 把替换数据按照顺序插入到你截取得位置</span><br><span class="line">-&gt; 注意: **从哪个索引开始删除, 替换数据得第一个就插入哪个位置**</span><br><span class="line">=&gt; 作用: 有两个</span><br><span class="line">1.截取数组</span><br><span class="line">2.替换新内容</span><br><span class="line">=&gt; 返回值: 一定是一个数组</span><br><span class="line">  -&gt; 如果你截取多个数据, 数组里面有多个</span><br><span class="line">  -&gt; 如果你说截取一个数据, 数组里面有一个</span><br><span class="line">  -&gt; 如果你一个都不截取, 那么是一个空数组</span><br><span class="line">=&gt; 直接操作原始数组</span><br></pre></td></tr></table></figure>   var arr = [&#39;hello&#39;, &#39;world&#39;, &#39;你好&#39;, &#39;世界&#39;]       var res = arr.splice(1, 2)       console.log(&#39;res: &#39;, res)       console.log(&#39;arr: &#39;, arr)   var res = arr.splice(1, 0, &#39;新来的&#39;, &#39;新来的2&#39;)       console.log(&#39;res: &#39;, res)       console.log(&#39;arr: &#39;, arr)       // [&#39;hello&#39;, &#39;world&#39;, &#39;新来的&#39;, &#39;你好&#39;, &#39;世界&#39;]       // [&#39;hello&#39;, &#39;新来的&#39;, &#39;world&#39;, &#39;你好&#39;, &#39;世界&#39;]</code></pre><h4 id="8-concat"><a href="#8-concat" class="headerlink" title="8. concat()"></a>8. concat()</h4><pre><code>    =&gt; 语法: 数组.concat(数组1, 数据2, ...)    =&gt; 作用:      -&gt; 如果参数是数组, 那么把数组拆开, 里面每一项追加到原数组后面      -&gt; 如果参数数数据, 那么直接追加    =&gt; 返回值: 追加好得数组    =&gt; 不改变原始数组    <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;你好&#x27;</span>, <span class="string">&#x27;世界&#x27;</span>]</span><br><span class="line">   <span class="keyword">var</span> res = arr.<span class="title function_">concat</span>([<span class="number">10</span>, <span class="number">20</span>], [<span class="number">30</span>, <span class="number">40</span>], <span class="number">100</span>)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br></pre></td></tr></table></figure></code></pre><h4 id="9-slice"><a href="#9-slice" class="headerlink" title="9. slice()"></a>9. slice()</h4><pre><code>    =&gt; 语法:      1. 数组.slice(开始索引, 结束索引) - 包前不包后         -&gt; 第一个参数可以不写, 表示从头         -&gt; 第二个参数可以不写, 表示到尾      2. 数组.slice(开始索引, 结束索引) - 包前不包后         -&gt; 参数可以写一个负整数         -&gt; 当你书写了一个负整数以后, 表示 length + 负整数         =&gt; 作用: 获取数组里面得某些数据         =&gt; 返回值: 一个数组           -&gt; 如果你获取多个数据, 数组里面有多个           -&gt; 如果你获取一个数据, 那么数组里面有一个           -&gt; 如果你一个都不获取, 那么是个空数组         =&gt; 不改变原始数组   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;你好&#x27;</span>, <span class="string">&#x27;世界&#x27;</span>]</span><br><span class="line">    <span class="keyword">var</span> res = arr.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res : &#x27;</span>, res)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;arr : &#x27;</span>, arr)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 因为 length 是 4, -2 得位置实际上相当于 4 + -2, 2</span></span><br><span class="line">    <span class="keyword">var</span> res2 = arr.<span class="title function_">slice</span>(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res2 : &#x27;</span>, res2)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;arr : &#x27;</span>, arr)</span><br></pre></td></tr></table></figure></code></pre><h4 id="10-join"><a href="#10-join" class="headerlink" title="10. join()"></a>10. join()</h4><pre><code>     =&gt; 语法: 数组.join(&#39;连接符号&#39;)       -&gt; 不传递, 是按照 逗号(,) 连接       -&gt; 你传递什么, 按照什么连接     =&gt; 作用: 把数组里面得每一个数据使用连接符号连接在一起     =&gt; 返回值: 是一个连接好得内容, 是一个 String 类型   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;你好&#x27;</span>, <span class="string">&#x27;世界&#x27;</span>]</span><br><span class="line"> <span class="keyword">var</span> res = arr.<span class="title function_">join</span>(<span class="string">&#x27;abcd&#x27;</span>)</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br></pre></td></tr></table></figure></code></pre><h4 id="11-indexOf"><a href="#11-indexOf" class="headerlink" title="11. indexOf()"></a>11. indexOf()</h4><pre><code>​    =&gt; 语法:​      1. 数组.indexOf(数据)​      2. 数组.indexOf(数据, 开始索引)​        -&gt; 从哪个索引开始向后查找​    =&gt; 作用: 正向查看数组里面指定这个数据得索引​    =&gt; 返回值:​      -&gt; 如果有这个数据, 是第一个满足条件得数据得索引​      -&gt; 如果没有这个数据, 那么是 -1</code></pre><h4 id="12-lastIndexOf"><a href="#12-lastIndexOf" class="headerlink" title="12. lastIndexOf()"></a>12. lastIndexOf()</h4><pre><code>    =&gt; 语法:      1. 数组.lastIndexOf(数据)      2. 数组.lastIndexOf(数据, 开始索引)        -&gt; 从哪一个索引开始向前查找    =&gt; 作用: 反向查看数组里面指定这个数据得索引    =&gt; 返回值:      -&gt; 如果有, 就是找到得第一个数据得索引      -&gt; 如果没有就是 -1      -&gt; 注意: 虽然是从后向前查找, 但是索引还是正常索引</code></pre><h4 id="13-forEach"><a href="#13-forEach" class="headerlink" title="13. forEach()"></a>13. forEach()</h4><pre><code>    =&gt; 语法: 数组.forEach(function (item, index, arr) &#123;&#125;)      -&gt; item: 数组得每一项      -&gt; index: 数组每一项得索引      -&gt; arr: 原始数组    =&gt; 作用: 取代 for 循环得作用, 遍历数组    =&gt; 没有返回值</code></pre><h4 id="14-map"><a href="#14-map" class="headerlink" title="14. map()"></a>14. map()</h4><pre><code>    =&gt; 语法: 数组.map(function (item, index, arr) &#123;&#125;)      -&gt; item: 数组得每一项      -&gt; index: 数组每一项得索引      -&gt; arr: 原始数组    =&gt; 作用: 映射数组    =&gt; 返回值: 是一个新的数组      -&gt; 里面是对原始数组每一个数据得操作      -&gt; 返回值数组, 一定和原始数组长度一样    =&gt; 不改变原始数组</code></pre><h4 id="15-filter"><a href="#15-filter" class="headerlink" title="15. filter()"></a>15. filter()</h4><pre><code>    =&gt; 语法: 数组.filter(function (item, index, arr) &#123;&#125;)      -&gt; item: 数组得每一项      -&gt; index: 数组每一项得索引      -&gt; arr: 原始数组    =&gt; 作用: 过滤原始数组中得数据, 把满足条件得放在新数组里面    =&gt; 返回值: 新数组, 里面是所有原始数组中满足条件得项    =&gt; 不改变原始数组</code></pre><h4 id="16-every"><a href="#16-every" class="headerlink" title="16. every()"></a>16. every()</h4><pre><code>    =&gt; 语法: 数组.every(function (item, index, arr) &#123;&#125;)      -&gt; item: 数组得每一项      -&gt; index: 数组每一项得索引      -&gt; arr: 原始数组    =&gt; 作用: 判断原始数组里面是不是每一个都满足条件    =&gt; 返回值: 是一个布尔值      -&gt; 如果原始数组中每一个都满足条件, 那么返回 true      -&gt; 只要原始数组中有任意一个不满足条件, 那么就返回 false</code></pre><h4 id="17-some"><a href="#17-some" class="headerlink" title="17. some()"></a>17. some()</h4><pre><code>    =&gt; 语法: 数组.some(function (item, index, arr) &#123;&#125;)      -&gt; item: 数组得每一项      -&gt; index: 数组每一项得索引      -&gt; arr: 原始数组    =&gt; 作用: 判断数组中是不是有某一个满足条件    =&gt; 返回值: 一个布尔值      -&gt; 如果数组中有任意一个数据满足条件, 那么返回 true      -&gt; 如果数组中所有数据都不满足条件, 那么返回 false</code></pre><h4 id="18-copyWithin"><a href="#18-copyWithin" class="headerlink" title="18. copyWithin()"></a>18. copyWithin()</h4><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=&gt; 语法: 数组.copyWithin(目标位置, 开始索引, 结束索引)</span><br><span class="line">    -&gt; 目标位置: 当你替换内容得时候, 从哪一个索引位置开始替换</span><br><span class="line">    -&gt; 开始索引: 数组哪一个索引位置开始当作替换内容, 默认值是 0</span><br><span class="line">    -&gt; 结束索引: 数组哪一个索引位置结束当作替换内容, 默认是末尾</span><br><span class="line">    -&gt; 包前不包后</span><br><span class="line">  =&gt; 作用: 使用数组里面得内容替换数组里面得内容</span><br><span class="line">  =&gt; 返回值: 是一个新的数组</span><br><span class="line">    -&gt; 替换后得数组</span><br></pre></td></tr></table></figure></code></pre><h4 id="19-fill"><a href="#19-fill" class="headerlink" title="19. fill()"></a>19. fill()</h4><pre><code>    =&gt; 语法: 数组.fill(要填充得数据, 开始索引, 结束索引)      -&gt; 要填充得数据: 你想用什么数据填充数组里面每一位      -&gt; 开始索引: 从哪一个索引开始填充, 默认值是 0      -&gt; 结束索引: 填充到哪一个索引位置, 默认值是 末尾      -&gt; 前提: 数组要有 length      -&gt; 包前不包后    =&gt; 作用: 使用指定数据区填充数组    =&gt; 返回值: 填充好得数组</code></pre><h4 id="20-includes"><a href="#20-includes" class="headerlink" title="20. includes()"></a>20. includes()</h4><pre><code>    =&gt; 语法: 数组.includes(数据)    =&gt; 作用: 查看数组中是不是有某一个数据    =&gt; 返回值: 一个布尔值      -&gt; 有这个数据, 就是 true      -&gt; 没有这个数据, 就是 false</code></pre><h4 id="21-flat"><a href="#21-flat" class="headerlink" title="21. flat()"></a>21. flat()</h4><pre><code>    =&gt; 语法: 数组.flat(数字)      -&gt; 数字: 表示扁平化多少层, 默认是 1      -&gt; 数字这个参数还可以填写 Infinity    =&gt; 作用: 拍平数组    =&gt; 返回值: 拍平以后得数组</code></pre><h4 id="22-flatMap"><a href="#22-flatMap" class="headerlink" title="22. flatMap()"></a>22. flatMap()</h4><pre><code>    =&gt; 语法: 数组.flatMap(function (item, index, arr) &#123;&#125;)    =&gt; 作用: 拍平数组, 但是只能拍一层    =&gt; 返回值: 是一个新的数组      -&gt; 一边拍平, 一边映射</code></pre><h4 id="23-find"><a href="#23-find" class="headerlink" title="23. find()"></a>23. find()</h4><pre><code>    =&gt; 语法: 数组.find(function (item) &#123;&#125;)    =&gt; 作用: 根据条件找到数组里面满足条件得数据    =&gt; 返回值: 找到得那个 **数据**</code></pre><h4 id="24-findIndex"><a href="#24-findIndex" class="headerlink" title="24. findIndex()"></a>24. findIndex()</h4><pre><code>    =&gt; 语法: 数组.findIndex(function (item) &#123;&#125;)    =&gt; 作用: 根据条件找到数组里面满足条件得数据    =&gt; 返回值: 找到得那个 **数据得索引**</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;数组常用方法总结&quot;&gt;&lt;a href=&quot;#数组常用方法总结&quot; class=&quot;headerlink&quot; title=&quot;数组常用方法总结&quot;&gt;&lt;/a&gt;数组常用方法总结&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;    01_数组常用方法
      =&amp;gt; 数组基础方法
     </summary>
      
    
    
    
    <category term="前端" scheme="https://lcl.shiqi217.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JS" scheme="https://lcl.shiqi217.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS面试题</title>
    <link href="https://lcl.shiqi217.com/2022/09/05/%E5%89%8D%E7%AB%AF/JS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://lcl.shiqi217.com/2022/09/05/%E5%89%8D%E7%AB%AF/JS%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-09-05T12:00:09.000Z</published>
    <updated>2022-11-06T13:55:05.080Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JavaScript基础面试题"><a href="#JavaScript基础面试题" class="headerlink" title="JavaScript基础面试题"></a>JavaScript基础面试题</h3><h4 id="面试题：延迟加载JS有哪些方式？"><a href="#面试题：延迟加载JS有哪些方式？" class="headerlink" title="面试题：延迟加载JS有哪些方式？"></a>面试题：延迟加载JS有哪些方式？</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">延迟加载：<span class="keyword">async</span>、defer</span><br><span class="line">例如：&lt;script defer type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&#x27;script.js&#x27;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">defer : 等html全部解析完成，才会执行js代码，顺次执行js脚本。</span><br><span class="line"><span class="keyword">async</span> : <span class="keyword">async</span>是和html解析同步的（一起的），不是顺次执行js脚本（谁先加载完谁先执行）。</span><br></pre></td></tr></table></figure><h4 id="面试题：JS数据类型有哪些？"><a href="#面试题：JS数据类型有哪些？" class="headerlink" title="面试题：JS数据类型有哪些？"></a>面试题：JS数据类型有哪些？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本类型：string、number、boolean、undefined、null、symbol、bigint</span><br><span class="line">引用类型：object</span><br><span class="line"></span><br><span class="line">NaN是一个数值类型，但是不是一个具体的数字。</span><br></pre></td></tr></table></figure><h4 id="面试题：JS数据类型考题"><a href="#面试题：JS数据类型考题" class="headerlink" title="面试题：JS数据类型考题"></a>面试题：JS数据类型考题</h4><h5 id="考题一："><a href="#考题一：" class="headerlink" title="考题一："></a>考题一：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">true</span> + <span class="number">1</span> );     <span class="comment">//2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;name&#x27;</span>+<span class="literal">true</span> );  <span class="comment">//nametrue</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">undefined</span> + <span class="number">1</span> ); <span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="keyword">typeof</span> <span class="literal">undefined</span> ); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><h5 id="考题二："><a href="#考题二：" class="headerlink" title="考题二："></a>考题二：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">typeof</span>(<span class="title class_">NaN</span>) );       <span class="comment">//number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">typeof</span>(<span class="literal">null</span>) );      <span class="comment">//object</span></span><br></pre></td></tr></table></figure><h4 id="面试题：null和undefined的区别"><a href="#面试题：null和undefined的区别" class="headerlink" title="面试题：null和undefined的区别"></a>面试题：null和undefined的区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 作者在设计js的都是先设计的null（为什么设计了null：最初设计js的时候借鉴了java的语言）</span><br><span class="line">2. null会被隐式转换成0，很不容易发现错误。</span><br><span class="line">3. 先有null后有undefined，出来undefined是为了填补之前的坑。</span><br><span class="line"></span><br><span class="line">具体区别：JavaScript的最初版本是这样区分的：null是一个表示&quot;无&quot;的对象（空对象指针），转为数值时为0；undefined是一个表示&quot;无&quot;的原始值，转为数值时为NaN。</span><br></pre></td></tr></table></figure><h4 id="面试题：-和-有什么不同？"><a href="#面试题：-和-有什么不同？" class="headerlink" title="面试题：==和===有什么不同？"></a>面试题：==和===有什么不同？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==  :  比较的是值</span><br><span class="line"></span><br><span class="line">string == number || boolean || number ....都会隐式转换</span><br><span class="line">通过valueOf转换（valueOf() 方法通常由 JavaScript 在后台自动调用，并不显式地出现在代码中。）</span><br><span class="line"></span><br><span class="line">=== ： 除了比较值，还比较类型</span><br></pre></td></tr></table></figure><h4 id="面试题：JS微任务和宏任务"><a href="#面试题：JS微任务和宏任务" class="headerlink" title="面试题：JS微任务和宏任务"></a>面试题：JS微任务和宏任务</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. js是单线程的语言。</span><br><span class="line">2. js代码执行流程：同步执行完==》事件循环</span><br><span class="line">同步的任务都执行完了，才会执行事件循环的内容</span><br><span class="line">进入事件循环：请求、定时器、事件....</span><br><span class="line">3. 事件循环中包含：【微任务、宏任务】</span><br><span class="line">微任务：promise.then</span><br><span class="line">宏任务：setTimeout..</span><br><span class="line"></span><br><span class="line">要执行宏任务的前提是清空了所有的微任务</span><br><span class="line"></span><br><span class="line">流程：同步==》事件循环【微任务和宏任务】==》微任务==》宏任务=》微任务...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="面试题：JS作用域考题"><a href="#面试题：JS作用域考题" class="headerlink" title="面试题：JS作用域考题"></a>面试题：JS作用域考题</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 除了函数外，js是没有块级作用域。</span><br><span class="line">2. 作用域链：内部可以访问外部的变量，但是外部不能访问内部的变量。</span><br><span class="line"> 注意：如果内部有，优先查找到内部，如果内部没有就查找外部的。</span><br><span class="line">3. 注意  声明变量是用var还是没有写（window.）</span><br><span class="line">4. 注意：js有变量提升的机制【变量悬挂声明】 </span><br><span class="line">5. 优先级：声明变量 &gt; 声明普通函数 &gt; 参数 &gt; 变量提升</span><br></pre></td></tr></table></figure><h5 id="面试的时候怎么看："><a href="#面试的时候怎么看：" class="headerlink" title="面试的时候怎么看："></a>面试的时候怎么看：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 本层作用域有没有此变量【注意变量提升】</span><br><span class="line">2. 注意：js除了函数外没有块级作用域</span><br><span class="line">3. 普通声明函数是不看写函数的时候顺序</span><br></pre></td></tr></table></figure><h5 id="考题一：-1"><a href="#考题一：-1" class="headerlink" title="考题一："></a>考题一：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( b );</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( b );</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( b );</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">c</span>();</span><br></pre></td></tr></table></figure><h5 id="考题二：-1"><a href="#考题二：-1" class="headerlink" title="考题二："></a>考题二：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">typeof</span> name == <span class="string">&#x27;undefined&#x27;</span> )&#123;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;111&#x27;</span>+name);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;222&#x27;</span>+name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h5 id="考题三："><a href="#考题三：" class="headerlink" title="考题三："></a>考题三：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"> a </span>)&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a ); <span class="comment">//10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>( <span class="number">100</span> );</span><br></pre></td></tr></table></figure><h4 id="面试题：JS对象考题"><a href="#面试题：JS对象考题" class="headerlink" title="面试题：JS对象考题"></a>面试题：JS对象考题</h4><h5 id="JS对象注意点："><a href="#JS对象注意点：" class="headerlink" title="JS对象注意点："></a>JS对象注意点：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 对象是通过new操作符构建出来的，所以对象之间不相等(除了引用外)；</span><br><span class="line">2. 对象注意：引用类型(共同一个地址)；</span><br><span class="line">3. 对象的key都是字符串类型；</span><br><span class="line">4. 对象如何找属性|方法；</span><br><span class="line">查找规则：先在对象本身找 ===&gt; 构造函数中找 ===&gt; 对象原型中找 ===&gt; 构造函数原型中找 ===&gt; 对象上一层原型查找</span><br></pre></td></tr></table></figure><h5 id="考题一：-2"><a href="#考题一：-2" class="headerlink" title="考题一："></a>考题一：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] === [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]   <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h5 id="考题二：-2"><a href="#考题二：-2" class="headerlink" title="考题二："></a>考题二：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line"><span class="attr">a</span>:<span class="string">&#x27;hellow&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj2.<span class="property">a</span> = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1); <span class="comment">//&#123;a:world&#125;</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h5 id="考题三：-1"><a href="#考题三：-1" class="headerlink" title="考题三："></a>考题三：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line"><span class="attr">key</span>:<span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = &#123;</span><br><span class="line"><span class="attr">key</span>:<span class="string">&#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a[b] = <span class="string">&#x27;123&#x27;</span>; <span class="comment">//相当于在a里面添加了一个[object object]:&#x27;123&#x27;</span></span><br><span class="line">a[c] = <span class="string">&#x27;456&#x27;</span>; <span class="comment">//相当于在a里面把上次添加的覆盖了一个[object object]:&#x27;456&#x27;</span></span><br><span class="line"><span class="comment">//后者覆盖前者 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a[b] ); <span class="comment">// 456</span></span><br></pre></td></tr></table></figure><h4 id="面试题：JS作用域-this指向-原型的考题"><a href="#面试题：JS作用域-this指向-原型的考题" class="headerlink" title="面试题：JS作用域+this指向+原型的考题"></a>面试题：JS作用域+this指向+原型的考题</h4><h5 id="考题一：-3"><a href="#考题一：-3" class="headerlink" title="考题一："></a>考题一：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">getName = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)&#125; <span class="comment">//注意是全局的window.</span></span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)&#125;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">getName</span>();    <span class="comment">//2</span></span><br><span class="line"><span class="title function_">getName</span>();   <span class="comment">//4</span></span><br><span class="line"><span class="title class_">Foo</span>().<span class="title function_">getName</span>();  <span class="comment">//1</span></span><br><span class="line"><span class="title function_">getName</span>();  <span class="comment">//1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Foo</span>().<span class="title function_">getName</span>();<span class="comment">//3</span></span><br></pre></td></tr></table></figure><h5 id="考题二：-3"><a href="#考题二：-3" class="headerlink" title="考题二："></a>考题二：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line"><span class="attr">a</span>:<span class="number">10</span>,</span><br><span class="line"><span class="attr">b</span>:&#123;</span><br><span class="line"><span class="attr">a</span>:<span class="number">2</span>,</span><br><span class="line"><span class="attr">fn</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span> );   <span class="comment">//代表b对象</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">o.<span class="property">b</span>.<span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><h5 id="考题三：-2"><a href="#考题三：-2" class="headerlink" title="考题三："></a>考题三：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;ByteDance&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getA</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span> );</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">A</span>();</span><br><span class="line"><span class="keyword">let</span> funcA = a.<span class="property">getA</span>;</span><br><span class="line"><span class="title function_">funcA</span>();  <span class="comment">//this代表window</span></span><br></pre></td></tr></table></figure><h5 id="考题四："><a href="#考题四：" class="headerlink" title="考题四："></a>考题四：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> length = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="attr">length</span>:<span class="number">5</span>,</span><br><span class="line"><span class="attr">test1</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">test2</span> = fn;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj.<span class="title function_">test1</span>() ); <span class="comment">//11</span></span><br><span class="line"><span class="comment">//11 === 6 false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">fn</span>()===obj.<span class="title function_">test2</span>() ); <span class="comment">//false</span></span><br><span class="line"><span class="comment">//11 === 6 false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj.<span class="title function_">test1</span>() == obj.<span class="title function_">test2</span>() ); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h4 id="面试题：JS判断变量是不是数组，你能写出哪些方法？"><a href="#面试题：JS判断变量是不是数组，你能写出哪些方法？" class="headerlink" title="面试题：JS判断变量是不是数组，你能写出哪些方法？"></a>面试题：JS判断变量是不是数组，你能写出哪些方法？</h4><h5 id="方式一：isArray"><a href="#方式一：isArray" class="headerlink" title="方式一：isArray"></a>方式一：isArray</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Array</span>.<span class="title function_">isArray</span>( arr ) );</span><br></pre></td></tr></table></figure><h5 id="方式二：instanceof-【可写-可不写】"><a href="#方式二：instanceof-【可写-可不写】" class="headerlink" title="方式二：instanceof  【可写,可不写】"></a>方式二：instanceof  【可写,可不写】</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( arr <span class="keyword">instanceof</span> <span class="title class_">Array</span> );</span><br></pre></td></tr></table></figure><h5 id="方式三：原型prototype"><a href="#方式三：原型prototype" class="headerlink" title="方式三：原型prototype"></a>方式三：原型prototype</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr).<span class="title function_">indexOf</span>(<span class="string">&#x27;Array&#x27;</span>) &gt; -<span class="number">1</span> );</span><br></pre></td></tr></table></figure><h5 id="方式四：isPrototypeOf"><a href="#方式四：isPrototypeOf" class="headerlink" title="方式四：isPrototypeOf()"></a>方式四：isPrototypeOf()</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(  <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(arr) )</span><br></pre></td></tr></table></figure><h5 id="方式五：constructor"><a href="#方式五：constructor" class="headerlink" title="方式五：constructor"></a>方式五：constructor</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(  arr.<span class="property">constructor</span>.<span class="title function_">toString</span>().<span class="title function_">indexOf</span>(<span class="string">&#x27;Array&#x27;</span>) &gt; -<span class="number">1</span> )</span><br></pre></td></tr></table></figure><h4 id="面试题：slice是干嘛的、splice是否会改变原数组"><a href="#面试题：slice是干嘛的、splice是否会改变原数组" class="headerlink" title="面试题：slice是干嘛的、splice是否会改变原数组"></a>面试题：slice是干嘛的、splice是否会改变原数组</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. slice是来截取的</span><br><span class="line">参数可以写slice(3)、slice(1,3)、slice(-3)</span><br><span class="line">返回的是一个新的数组</span><br><span class="line">2. splice 功能有：插入、删除、替换</span><br><span class="line">返回：删除的元素</span><br><span class="line">1. 删除功能，第一个参数为第一项位置，第二个参数为要删除几个。</span><br><span class="line">2.插入功能，第一个参数（插入位置），第二个参数（0），第三个参数（插入的项）</span><br><span class="line">3.替换功能，第一个参数（起始位置），第二个参数（删除的项数），第三个参数（插入任意数量的项</span><br><span class="line">）</span><br><span class="line"></span><br><span class="line">该方法会改变原数组</span><br></pre></td></tr></table></figure><h4 id="面试题：JS数组去重"><a href="#面试题：JS数组去重" class="headerlink" title="面试题：JS数组去重"></a>面试题：JS数组去重</h4><h5 id="方式一：new-set"><a href="#方式一：new-set" class="headerlink" title="方式一：new set"></a>方式一：new set</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>];</span><br><span class="line"><span class="comment">//从对象转换成数组</span></span><br><span class="line"><span class="comment">//1.ES6新增的方法Array.from()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(  <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr1) ) );</span><br><span class="line"><span class="comment">//2.通过扩展运算符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(  [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr1) ] );</span><br><span class="line"><span class="comment">//3. 函数封装</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(  <span class="title function_">unique</span>(arr1) );</span><br></pre></td></tr></table></figure><h5 id="方式二：indexOf"><a href="#方式二：indexOf" class="headerlink" title="方式二：indexOf"></a>方式二：indexOf</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params"> arr </span>)&#123;</span><br><span class="line"><span class="keyword">var</span> brr = [];</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(  brr.<span class="title function_">indexOf</span>(arr[i]) == -<span class="number">1</span> )&#123;</span><br><span class="line">brr.<span class="title function_">push</span>( arr[i] );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> brr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">unique</span>(arr2) );</span><br></pre></td></tr></table></figure><h5 id="方式三：sort-（排序）"><a href="#方式三：sort-（排序）" class="headerlink" title="方式三：sort （排序）"></a>方式三：sort （排序）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params"> arr </span>)&#123;</span><br><span class="line">arr = arr.<span class="title function_">sort</span>();</span><br><span class="line"><span class="keyword">var</span> brr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>( arr[i] !== arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">brr.<span class="title function_">push</span>( arr[i] );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> brr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">unique</span>(arr3) );</span><br></pre></td></tr></table></figure><h4 id="面试题：找出多维数组最大值"><a href="#面试题：找出多维数组最大值" class="headerlink" title="面试题：找出多维数组最大值"></a>面试题：找出多维数组最大值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fnArr</span>(<span class="params">arr</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> newArr = [];</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">newArr.<span class="title function_">push</span>( <span class="title class_">Math</span>.<span class="title function_">max</span>(...item)  )</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fnArr</span>([</span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">[<span class="number">13</span>,<span class="number">27</span>,<span class="number">18</span>,<span class="number">26</span>],</span><br><span class="line">[<span class="number">32</span>,<span class="number">35</span>,<span class="number">37</span>,<span class="number">39</span>],</span><br><span class="line">[<span class="number">1000</span>,<span class="number">1001</span>,<span class="number">857</span>,<span class="number">1</span>]</span><br><span class="line">]));</span><br></pre></td></tr></table></figure><h4 id="面试题：给字符串新增方法实现功能"><a href="#面试题：给字符串新增方法实现功能" class="headerlink" title="面试题：给字符串新增方法实现功能"></a>面试题：给字符串新增方法实现功能</h4><p>​        给字符串对象定义一个addPrefix函数，当传入一个字符串str时，它会返回新的带有指定前缀的字符串，例如：</p><p>console.log( ‘world’.addPrefix(‘hello’) )  控制台会输出helloworld</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">解答：</span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addPrefix</span> = <span class="keyword">function</span>(<span class="params">str</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> str  + <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;world&#x27;</span>.<span class="title function_">addPrefix</span>(<span class="string">&#x27;hello&#x27;</span>) )</span><br></pre></td></tr></table></figure><h4 id="面试题：找出字符串出现最多次数的字符以及次数"><a href="#面试题：找出字符串出现最多次数的字符以及次数" class="headerlink" title="面试题：找出字符串出现最多次数的字符以及次数*"></a>面试题：找出字符串出现最多次数的字符以及次数*</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;aaabbbbbccddddddddddx&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;str.<span class="property">length</span>;i++)&#123;</span><br><span class="line"><span class="keyword">var</span> char = str.<span class="title function_">charAt</span>(i);</span><br><span class="line"><span class="keyword">if</span>( obj[char] )&#123;</span><br><span class="line">obj[char]++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">obj[char] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj );</span><br><span class="line"><span class="comment">//统计出来最大值</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> key <span class="keyword">in</span> obj )&#123;</span><br><span class="line"><span class="keyword">if</span>( max &lt; obj[key] )&#123;</span><br><span class="line">max = obj[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拿最大值去对比</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> key <span class="keyword">in</span> obj )&#123;</span><br><span class="line"><span class="keyword">if</span>( obj[key] == max )&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;最多的字符是&#x27;</span>+key);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;出现的次数是&#x27;</span>+max);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题：new操作符具体做了什么"><a href="#面试题：new操作符具体做了什么" class="headerlink" title="面试题：new操作符具体做了什么*"></a>面试题：new操作符具体做了什么*</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 创建了一个空的对象</span><br><span class="line">2. 将空对象的原型，指向于构造函数的原型</span><br><span class="line">3. 将空对象作为构造函数的上下文（改变this指向）</span><br><span class="line">4. 对构造函数有返回值的处理判断</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fun</span>(<span class="params"> age,name </span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params"> fn , ...args </span>)&#123;</span><br><span class="line"><span class="comment">//1. 创建了一个空的对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;; <span class="comment">//var obj = Object.create(&#123;&#125;)</span></span><br><span class="line"><span class="comment">//2. 将空对象的原型，指向于构造函数的原型</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj,fn.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">//3. 将空对象作为构造函数的上下文（改变this指向）</span></span><br><span class="line"><span class="keyword">var</span> result = fn.<span class="title function_">apply</span>(obj,args);</span><br><span class="line"><span class="comment">//4. 对构造函数有返回值的处理判断</span></span><br><span class="line"><span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? result : obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">create</span>(<span class="title class_">Fun</span>,<span class="number">18</span>,<span class="string">&#x27;张三&#x27;</span>)   )</span><br></pre></td></tr></table></figure><h4 id="面试题：闭包"><a href="#面试题：闭包" class="headerlink" title="面试题：闭包**"></a>面试题：闭包**</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 闭包是什么</span><br><span class="line">闭包是一个函数加上到创建函数的作用域的连接，闭包“关闭”了函数的自由变量。</span><br><span class="line">2. 闭包可以解决什么问题【闭包的优点】</span><br><span class="line">2.1 内部函数可以访问到外部函数的局部变量</span><br><span class="line">2.2 闭包可以解决的问题</span><br><span class="line">var lis = document.getElementsByTagName(&#x27;li&#x27;);</span><br><span class="line">      for(var i=0;i&lt;lis.length;i++)&#123;</span><br><span class="line">        (function(i)&#123;</span><br><span class="line">          lis[i].onclick = function()&#123;</span><br><span class="line">            alert(i);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)(i)</span><br><span class="line">      &#125;</span><br><span class="line">3. 闭包的缺点</span><br><span class="line">3.1 变量会驻留在内存中，造成内存损耗问题。</span><br><span class="line">解决：把闭包的函数设置为null</span><br><span class="line">  3.2 内存泄漏【ie】 ==&gt; 可说可不说，如果说一定要提到ie</span><br></pre></td></tr></table></figure><h4 id="面试题：原型链"><a href="#面试题：原型链" class="headerlink" title="面试题：原型链"></a>面试题：原型链</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 原型可以解决什么问题</span><br><span class="line">对象共享属性和共享方法</span><br><span class="line">2. 谁有原型</span><br><span class="line">函数拥有：prototype</span><br><span class="line">对象拥有：__proto__</span><br><span class="line">3. 对象查找属性或者方法的顺序</span><br><span class="line">先在对象本身查找 --&gt; 构造函数中查找 --&gt; 对象的原型 --&gt; 构造函数的原型中 --&gt; 当前原型的原型中查找</span><br><span class="line">4. 原型链</span><br><span class="line">4.1 是什么？：就是把原型串联起来</span><br><span class="line">4.2 原型链的最顶端是null</span><br></pre></td></tr></table></figure><h4 id="面试题：-JS继承有哪些方式"><a href="#面试题：-JS继承有哪些方式" class="headerlink" title="面试题： JS继承有哪些方式"></a>面试题： JS继承有哪些方式</h4><h5 id="方式一：ES6"><a href="#方式一：ES6" class="headerlink" title="方式一：ES6"></a>方式一：ES6</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span>&#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">super</span>();</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> o1 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( o1,o1.<span class="property">name</span>,o1.<span class="property">age</span> );</span><br></pre></td></tr></table></figure><h5 id="方式二：原型链继承"><a href="#方式二：原型链继承" class="headerlink" title="方式二：原型链继承"></a>方式二：原型链继承</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( o2,o2.<span class="property">name</span>,o2.<span class="property">age</span> );</span><br></pre></td></tr></table></figure><h5 id="方式三：借用构造函数继承"><a href="#方式三：借用构造函数继承" class="headerlink" title="方式三：借用构造函数继承"></a>方式三：借用构造函数继承</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">22</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line"><span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> o3 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( o3,o3.<span class="property">name</span>,o3.<span class="property">age</span> );</span><br></pre></td></tr></table></figure><h5 id="方式四：组合式继承"><a href="#方式四：组合式继承" class="headerlink" title="方式四：组合式继承"></a>方式四：组合式继承</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="keyword">let</span> o4 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( o4,o4.<span class="property">name</span>,o4.<span class="property">age</span> );</span><br></pre></td></tr></table></figure><h4 id="面试题：说一下call、apply、bind区别"><a href="#面试题：说一下call、apply、bind区别" class="headerlink" title="面试题：说一下call、apply、bind区别"></a>面试题：说一下call、apply、bind区别</h4><h5 id="共同点：功能一致"><a href="#共同点：功能一致" class="headerlink" title="共同点：功能一致"></a>共同点：功能一致</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以改变this指向</span><br><span class="line"></span><br><span class="line">语法： 函数.call()、函数.apply()、函数.bind()</span><br></pre></td></tr></table></figure><h5 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. call、apply可以立即执行。bind不会立即执行，因为bind返回的是一个函数需要加入()执行。</span><br><span class="line">2. 参数不同：apply第二个参数是数组。call和bind有多个参数需要挨个写。</span><br></pre></td></tr></table></figure><h5 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 用apply的情况</span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">321</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>,arr1) )</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 用bind的情况</span><br><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> h1s = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;h1s&#x27;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">id</span> );</span><br><span class="line">&#125;.<span class="title function_">bind</span>(h1s)</span><br></pre></td></tr></table></figure><h4 id="面试题：sort背后原理是什么？"><a href="#面试题：sort背后原理是什么？" class="headerlink" title="面试题：sort背后原理是什么？"></a>面试题：sort背后原理是什么？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，数量小于10的数组使用 InsertionSort，比10大的数组则使用 QuickSort。</span><br><span class="line"></span><br><span class="line">之前的版本是：插入排序和快排，现在是冒泡</span><br><span class="line"></span><br><span class="line">原理实现链接：https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js</span><br><span class="line"></span><br><span class="line">***710行代码开始***</span><br></pre></td></tr></table></figure><h4 id="面试题：深拷贝和浅拷贝"><a href="#面试题：深拷贝和浅拷贝" class="headerlink" title="面试题：深拷贝和浅拷贝"></a>面试题：深拷贝和浅拷贝</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">共同点：复制</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 浅拷贝：只复制引用，而未复制真正的值。</span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(obj1);</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 深拷贝：是复制真正的值 （不同引用）</span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;</span><br><span class="line"><span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line"><span class="attr">b</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj4 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>( obj3 ));</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归的形式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">copyObj</span>(<span class="params"> obj </span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(  <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)  )&#123;</span><br><span class="line"><span class="keyword">var</span> newObj = [];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">var</span> newObj = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> key <span class="keyword">in</span> obj )&#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">typeof</span> obj[key] == <span class="string">&#x27;object&#x27;</span> )&#123;</span><br><span class="line">newObj[key] = <span class="title function_">copyObj</span>(obj[key]);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">newObj[key] = obj[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(  <span class="title function_">copyObj</span>(obj5)  );</span><br></pre></td></tr></table></figure><h4 id="面试题：localStorage、sessionStorage、cookie的区别"><a href="#面试题：localStorage、sessionStorage、cookie的区别" class="headerlink" title="面试题：localStorage、sessionStorage、cookie的区别"></a>面试题：localStorage、sessionStorage、cookie的区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">公共点：在客户端存放数据</span><br><span class="line">区别：</span><br><span class="line">1. 数据存放有效期</span><br><span class="line">sessionStorage : 仅在当前浏览器窗口关闭之前有效。【关闭浏览器就没了】</span><br><span class="line">localStorage   : 始终有效，窗口或者浏览器关闭也一直保存，所以叫持久化存储。</span><br><span class="line">cookie : 只在设置的cookie过期时间之前有效，即使窗口或者浏览器关闭也有效。</span><br><span class="line">2. localStorage、sessionStorage不可以设置过期时间</span><br><span class="line"> cookie 有过期时间，可以设置过期（把时间调整到之前的时间，就过期了）</span><br><span class="line">3. 存储大小的限制</span><br><span class="line">cookie存储量不能超过4k</span><br><span class="line">localStorage、sessionStorage不能超过5M</span><br><span class="line"></span><br><span class="line">****根据不同的浏览器存储的大小是不同的。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">总结了JS常出现的面试题</summary>
    
    
    
    <category term="前端" scheme="https://lcl.shiqi217.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JS" scheme="https://lcl.shiqi217.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>HTML及CSS面试题</title>
    <link href="https://lcl.shiqi217.com/2022/09/05/%E5%89%8D%E7%AB%AF/HTML%E4%B8%8ECSS/"/>
    <id>https://lcl.shiqi217.com/2022/09/05/%E5%89%8D%E7%AB%AF/HTML%E4%B8%8ECSS/</id>
    <published>2022-09-05T11:40:09.000Z</published>
    <updated>2022-11-06T13:53:46.828Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML面试题"><a href="#HTML面试题" class="headerlink" title="HTML面试题"></a>HTML面试题</h3><h4 id="面试题：行内元素有哪些？块级元素有哪些？-空-void-元素有哪些？"><a href="#面试题：行内元素有哪些？块级元素有哪些？-空-void-元素有哪些？" class="headerlink" title="面试题：行内元素有哪些？块级元素有哪些？ 空(void)元素有哪些？"></a>面试题：行内元素有哪些？块级元素有哪些？ 空(void)元素有哪些？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">行内元素：span、img、input...</span><br><span class="line">块级元素：div、footer、header、section、p、h1...h6...</span><br><span class="line">空元素：br、hr...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">元素之间的转换问题：</span><br><span class="line">display: inline;  把某元素转换成了行内元素      ===&gt;不独占一行的，并且不能设置宽高</span><br><span class="line">display: inline-block; 把某元素转换成了行内块元素 ===&gt;不独占一行的，可以设置宽高</span><br><span class="line">display: block;把某元素转换成了块元素   ===&gt;独占一行，并且可以设置宽高</span><br></pre></td></tr></table></figure><h4 id="面试题：页面导入样式时，使用link和-import有什么区别？"><a href="#面试题：页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="面试题：页面导入样式时，使用link和@import有什么区别？"></a>面试题：页面导入样式时，使用link和@import有什么区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">区别一：link先有，后有@import（兼容性link比@import兼容）；</span><br><span class="line">区别二：加载顺序差别，浏览器先加载的标签link，后加载@import</span><br></pre></td></tr></table></figure><h4 id="面试题：title与h1的区别、b与strong的区别、i与em的区别？"><a href="#面试题：title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="面试题：title与h1的区别、b与strong的区别、i与em的区别？"></a>面试题：title与h1的区别、b与strong的区别、i与em的区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title与h1的区别：</span><br><span class="line"></span><br><span class="line">定义：</span><br><span class="line">title：概括了网站信息，可以告诉搜索引擎或者用户关于这个网站的内容主题是什么</span><br><span class="line">h1：文章主题内容，告诉蜘蛛我们的网站内容最主要是什么</span><br><span class="line">区别：</span><br><span class="line">title他是显示在网页标题上、h1是显示在网页内容上</span><br><span class="line">title比h1添加的重要 (title &gt; h1 ) ==》对于seo的了解</span><br><span class="line">场景：</span><br><span class="line">网站的logo都是用h1标签包裹的</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b与strong的区别：</span><br><span class="line"></span><br><span class="line">定义：</span><br><span class="line">b：实体标签，用来给文字加粗的。</span><br><span class="line">strong：逻辑标签，用来加强字符语气的。</span><br><span class="line">区别：</span><br><span class="line">b标签只有加粗的样式，没有实际含义。</span><br><span class="line">strong表示标签内字符比较重要，用以强调的。</span><br><span class="line">题外话：为了符合css3的规范，b尽量少用该用strong就行了。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i与em的区别：</span><br><span class="line"></span><br><span class="line">定义：</span><br><span class="line">i:实体标签，用来做文字倾斜的。</span><br><span class="line">em：是逻辑标签，用来强调文字内容的</span><br><span class="line">区别：</span><br><span class="line">i只是一个倾斜标签，没有实际含义。</span><br><span class="line">em表示标签内字符重要，用以强调的。</span><br><span class="line">场景：</span><br><span class="line">i更多的用在字体图标，em术语上（医药，生物）。</span><br></pre></td></tr></table></figure><h4 id="面试题：img标签的title和alt有什么区别？"><a href="#面试题：img标签的title和alt有什么区别？" class="headerlink" title="面试题：img标签的title和alt有什么区别？"></a>面试题：img标签的title和alt有什么区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">区别一：</span><br><span class="line">title ： 鼠标移入到图片显示的值</span><br><span class="line">alt   ： 图片无法加载时显示的值</span><br><span class="line">区别二：</span><br><span class="line">在seo的层面上，蜘蛛抓取不到图片的内容，所以前端在写img标签的时候为了增加seo效果要加入alt属性来描述这张图是什么内容或者关键词。</span><br></pre></td></tr></table></figure><h4 id="面试题：png、jpg、gif-这些图片格式解释一下，分别什么时候用？"><a href="#面试题：png、jpg、gif-这些图片格式解释一下，分别什么时候用？" class="headerlink" title="面试题：png、jpg、gif 这些图片格式解释一下，分别什么时候用？"></a>面试题：png、jpg、gif 这些图片格式解释一下，分别什么时候用？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">png:无损压缩，尺寸体积要比jpg/jpeg的大，适合做小图标。</span><br><span class="line">jpg:采用压缩算法，有一点失真，比png体积要小，适合做中大图片。</span><br><span class="line">gif:一般是做动图的。</span><br><span class="line">webp：同时支持有损或者无损压缩，相同质量的图片，webp具有更小的体积。兼容性不是特别好。</span><br></pre></td></tr></table></figure><h3 id="1-2-CSS面试题"><a href="#1-2-CSS面试题" class="headerlink" title="1.2 CSS面试题"></a>1.2 CSS面试题</h3><h4 id="面试题：介绍一下CSS的盒子模型"><a href="#面试题：介绍一下CSS的盒子模型" class="headerlink" title="面试题：介绍一下CSS的盒子模型"></a>面试题：介绍一下CSS的盒子模型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CSS的盒子模型有哪些：标准盒子模型、IE盒子模型</span><br><span class="line">CSS的盒子模型区别：</span><br><span class="line">标准盒子模型：margin、border、padding、content</span><br><span class="line">IE盒子模型 ：margin、content（ border +  padding  + content ）</span><br><span class="line">通过CSS如何转换盒子模型：</span><br><span class="line">box-sizing: content-box;/*标准盒子模型*/</span><br><span class="line">box-sizing: border-box;  /*IE盒子模型*/</span><br></pre></td></tr></table></figure><h4 id="面试题：line-height和heigh区别【大厂】"><a href="#面试题：line-height和heigh区别【大厂】" class="headerlink" title="面试题：line-height和heigh区别【大厂】"></a>面试题：line-height和heigh区别【大厂】</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">line-height是每一行文字的高，如果文字换行则整个盒子高度会增大（行数*行高）。</span><br><span class="line">height是一个死值，就是这个盒子的高度。</span><br></pre></td></tr></table></figure><h4 id="面试题：CSS选择符有哪些？哪些属性可以继承？"><a href="#面试题：CSS选择符有哪些？哪些属性可以继承？" class="headerlink" title="面试题：CSS选择符有哪些？哪些属性可以继承？"></a>面试题：CSS选择符有哪些？哪些属性可以继承？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CSS选择符：</span><br><span class="line">    通配（*）</span><br><span class="line">    id选择器（#）</span><br><span class="line">    类选择器（.）</span><br><span class="line">    标签选择器（div、p、h1...）</span><br><span class="line">    相邻选择器(+)</span><br><span class="line">    后代选择器(ul li)</span><br><span class="line">    子元素选择器（ &gt; ）</span><br><span class="line">    属性选择器(a[href])</span><br><span class="line">    </span><br><span class="line">CSS属性哪些可以继承：</span><br><span class="line">文字系列：font-size、color、line-height、text-align...</span><br><span class="line">***不可继承属性：border、padding、margin...</span><br></pre></td></tr></table></figure><h4 id="面试题：CSS优先级算法如何计算？"><a href="#面试题：CSS优先级算法如何计算？" class="headerlink" title="面试题：CSS优先级算法如何计算？"></a>面试题：CSS优先级算法如何计算？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">优先级比较：!important &gt; 内联样式 &gt; id &gt; class &gt; 标签 &gt; 通配</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CSS权重计算：</span><br><span class="line">第一：内联样式（style）  权重值:1000</span><br><span class="line">第二：id选择器   权重值:100</span><br><span class="line">第三：类选择器   权重值:10</span><br><span class="line">第四：标签&amp;伪元素选择器   权重值:1</span><br><span class="line">第五：通配、&gt;、+         权重值:0</span><br></pre></td></tr></table></figure><h4 id="面试题：用CSS画一个三角形"><a href="#面试题：用CSS画一个三角形" class="headerlink" title="面试题：用CSS画一个三角形"></a>面试题：用CSS画一个三角形</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">用边框画（border）,例如：</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attr">height</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">border-<span class="attr">left</span>:100px solid transparent;</span><br><span class="line">border-<span class="attr">right</span>:100px solid transparent;</span><br><span class="line">border-<span class="attr">top</span>:100px solid transparent;</span><br><span class="line">border-<span class="attr">bottom</span>:100px solid #ccc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题：一个盒子不给宽度和高度如何水平垂直居中？"><a href="#面试题：一个盒子不给宽度和高度如何水平垂直居中？" class="headerlink" title="面试题：一个盒子不给宽度和高度如何水平垂直居中？"></a>面试题：一个盒子不给宽度和高度如何水平垂直居中？</h4><h5 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&#x27;container&#x27;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;main&#x27;</span>&gt;</span>main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.<span class="property">container</span>&#123;</span><br><span class="line"><span class="attr">display</span>: flex;</span><br><span class="line">justify-<span class="attr">content</span>: center;</span><br><span class="line">align-<span class="attr">items</span>: center;</span><br><span class="line"><span class="attr">width</span>: 300px;</span><br><span class="line"><span class="attr">height</span>: 300px;</span><br><span class="line"><span class="attr">border</span>:5px solid #ccc;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">main</span>&#123;</span><br><span class="line"><span class="attr">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&#x27;container&#x27;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;main&#x27;</span>&gt;</span>main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.<span class="property">container</span>&#123;</span><br><span class="line"><span class="attr">position</span>: relative;</span><br><span class="line"><span class="attr">width</span>: 300px;</span><br><span class="line"><span class="attr">height</span>: 300px;</span><br><span class="line"><span class="attr">border</span>:5px solid #ccc;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">main</span>&#123;</span><br><span class="line"><span class="attr">position</span>: absolute;</span><br><span class="line"><span class="attr">left</span>:<span class="number">50</span>%;</span><br><span class="line"><span class="attr">top</span>:<span class="number">50</span>%;</span><br><span class="line"><span class="attr">background</span>: red;</span><br><span class="line"><span class="attr">transform</span>: <span class="title function_">translate</span>(-<span class="number">50</span>%,-<span class="number">50</span>%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题：display有哪些值？说明他们的作用。"><a href="#面试题：display有哪些值？说明他们的作用。" class="headerlink" title="面试题：display有哪些值？说明他们的作用。"></a>面试题：display有哪些值？说明他们的作用。</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">none     隐藏元素</span><br><span class="line">block    把某某元素转换成块元素</span><br><span class="line">inline   把某某元素转换成内联元素</span><br><span class="line">inline-block 把某某元素转换成行内块元素</span><br></pre></td></tr></table></figure><h4 id="面试题：对BFC规范-块级格式化上下文：block-formatting-context-的理解？"><a href="#面试题：对BFC规范-块级格式化上下文：block-formatting-context-的理解？" class="headerlink" title="面试题：对BFC规范(块级格式化上下文：block formatting context)的理解？"></a>面试题：对BFC规范(块级格式化上下文：block formatting context)的理解？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BFC就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。</span><br><span class="line"></span><br><span class="line">1. 了解BFC ： 块级格式化上下文。</span><br><span class="line">2. BFC的原则：如果一个元素具有BFC，那么内部元素再怎么弄，都不会影响到外面的元素。</span><br><span class="line">3. 如何触发BFC：</span><br><span class="line">float的值非none</span><br><span class="line">overflow的值非visible</span><br><span class="line">display的值为：inline-block、table-cell...</span><br><span class="line">position的值为:absoute、fixed</span><br></pre></td></tr></table></figure><h4 id="面试题：清除浮动有哪些方式？"><a href="#面试题：清除浮动有哪些方式？" class="headerlink" title="面试题：清除浮动有哪些方式？"></a>面试题：清除浮动有哪些方式？</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 触发<span class="variable constant_">BFC</span></span><br><span class="line"><span class="number">2.</span> 多创建一个盒子，添加样式：<span class="attr">clear</span>: both;</span><br><span class="line"><span class="number">3.</span> after方式</span><br><span class="line"><span class="attr">ul</span>:after&#123;</span><br><span class="line"><span class="attr">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="attr">display</span>: block;</span><br><span class="line"><span class="attr">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题：在网页中的应该使用奇数还是偶数的字体？为什么呢？"><a href="#面试题：在网页中的应该使用奇数还是偶数的字体？为什么呢？" class="headerlink" title="面试题：在网页中的应该使用奇数还是偶数的字体？为什么呢？"></a>面试题：在网页中的应该使用奇数还是偶数的字体？为什么呢？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">偶数 : 让文字在浏览器上表现更好看。</span><br><span class="line"></span><br><span class="line">另外说明：ui给前端一般设计图都是偶数的，这样不管是布局也好，转换px也好，方便一点。</span><br></pre></td></tr></table></figure><h4 id="面试题：position有哪些值？分别是根据什么定位的？"><a href="#面试题：position有哪些值？分别是根据什么定位的？" class="headerlink" title="面试题：position有哪些值？分别是根据什么定位的？"></a>面试题：position有哪些值？分别是根据什么定位的？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static [默认]  没有定位</span><br><span class="line">fixed  固定定位，相对于浏览器窗口进行定位。</span><br><span class="line">relative  相对于自身定位，不脱离文档流。</span><br><span class="line">absolute相对于第一个有relative的父元素，脱离文档流。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">relative和absolute区别</span><br><span class="line">1. relative不脱离文档流 、absolute脱离文档流</span><br><span class="line">2. relative相对于自身 、 absolute相对于第一个有relative的父元素</span><br><span class="line">3. relative如果有left、right、top、bottom ==》left、top</span><br><span class="line"> absolute如果有left、right、top、bottom ==》left、right、top、bottom</span><br></pre></td></tr></table></figure><h4 id="面试题：写一个左中右布局占满屏幕，其中左、右俩块固定宽200，中间自适应宽，要求先加载中间块，请写出结构及样式。"><a href="#面试题：写一个左中右布局占满屏幕，其中左、右俩块固定宽200，中间自适应宽，要求先加载中间块，请写出结构及样式。" class="headerlink" title="面试题：写一个左中右布局占满屏幕，其中左、右俩块固定宽200，中间自适应宽，要求先加载中间块，请写出结构及样式。"></a>面试题：写一个左中右布局占满屏幕，其中左、右俩块固定宽200，中间自适应宽，要求先加载中间块，请写出结构及样式。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">双飞翼</span><br></pre></td></tr></table></figure><h4 id="面试题：什么是CSS-reset？"><a href="#面试题：什么是CSS-reset？" class="headerlink" title="面试题：什么是CSS reset？"></a>面试题：什么是CSS reset？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reset.css   是一个css文件，用来重置css样式的。</span><br><span class="line">normalize.css 为了增强跨浏览器渲染的一致性，一个CSS 重置样式库。</span><br></pre></td></tr></table></figure><h4 id="面试题：css-sprite是什么-有什么优缺点"><a href="#面试题：css-sprite是什么-有什么优缺点" class="headerlink" title="面试题：css sprite是什么,有什么优缺点"></a>面试题：css sprite是什么,有什么优缺点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 是什么</span><br><span class="line">把多个小图标合并成一张大图片。</span><br><span class="line">2. 优缺点</span><br><span class="line">优点：减少了http请求的次数，提升了性能。</span><br><span class="line">缺点：维护比较差（例如图片位置进行修改或者内容宽高修改）</span><br></pre></td></tr></table></figure><h4 id="面试题：display-none-与visibility-hidden-的区别"><a href="#面试题：display-none-与visibility-hidden-的区别" class="headerlink" title="面试题：display: none;与visibility: hidden;的区别"></a>面试题：display: none;与visibility: hidden;的区别</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 占用位置的区别</span><br><span class="line"><span class="attr">display</span>: none; 是不占用位置的</span><br><span class="line"><span class="attr">visibility</span>: hidden;   虽然隐藏了，但是占用位置</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 重绘和回流的问题</span><br><span class="line"></span><br><span class="line"><span class="attr">visibility</span>: hidden; 、 <span class="attr">display</span>: none;  产生重绘</span><br><span class="line"><span class="attr">display</span>: none;     还会产生一次回流</span><br><span class="line"></span><br><span class="line">产生回流一定会造成重绘，但是重绘不一定会造成回流。</span><br><span class="line"></span><br><span class="line">产生回流的情况：改变元素的位置(left、top...)、显示隐藏元素....</span><br><span class="line">产生重绘的情况：样式改变、换皮肤</span><br></pre></td></tr></table></figure><h4 id="面试题：opacity-和-rgba区别"><a href="#面试题：opacity-和-rgba区别" class="headerlink" title="面试题：opacity 和 rgba区别"></a>面试题：opacity 和 rgba区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">共同性：实现透明效果</span><br><span class="line"></span><br><span class="line">1. opacity 取值范围0到1之间，0表示完全透明，1表示不透明</span><br><span class="line">2. rgba   R表示红色，G表示绿色，B表示蓝色，取值可以在正整数或者百分数。A表示透明度取值0到1之间</span><br><span class="line"></span><br><span class="line">区别：继承的区别</span><br><span class="line">opacity会继承父元素的opacity属性，而RGBA设置的元素的后代元素不会继承不透明属性。</span><br></pre></td></tr></table></figure><h4 id="面试题：什么是语义化标签"><a href="#面试题：什么是语义化标签" class="headerlink" title="面试题：什么是语义化标签"></a>面试题：什么是语义化标签</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 易读性和维护性更好。</span><br><span class="line">2. seo成分会更好，蜘蛛抓取更好。</span><br><span class="line">3. IE8不兼容HTML5标签的。解决：可以通过html5shiv.js去处理。</span><br></pre></td></tr></table></figure><h4 id="面试题：-before-和-after中双冒号和单冒号-有什么区别？解释一下这2个伪元素的作用。"><a href="#面试题：-before-和-after中双冒号和单冒号-有什么区别？解释一下这2个伪元素的作用。" class="headerlink" title="面试题：::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。"></a>面试题：::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 区别</span><br><span class="line">:是伪类、::伪元素  ===》是为了做区分</span><br><span class="line"></span><br><span class="line">2.是什么？作用</span><br><span class="line">元素before之前 、 元素after之后</span><br><span class="line">作用：清除浮动、样式布局上也有作用</span><br></pre></td></tr></table></figure><h4 id="面试题：如何关闭IOS键盘首字母自动大写"><a href="#面试题：如何关闭IOS键盘首字母自动大写" class="headerlink" title="面试题：如何关闭IOS键盘首字母自动大写"></a>面试题：如何关闭IOS键盘首字母自动大写</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; autocapitalize=&#x27;off&#x27;&gt;</span><br></pre></td></tr></table></figure><h4 id="面试题：怎么让Chrome支持小于12px-的文字？"><a href="#面试题：怎么让Chrome支持小于12px-的文字？" class="headerlink" title="面试题：怎么让Chrome支持小于12px 的文字？"></a>面试题：怎么让Chrome支持小于12px 的文字？</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Chrome</span>默认字体大小是：16px</span><br><span class="line">**每个浏览器默认字体大小可能都不一样</span><br><span class="line"></span><br><span class="line">&lt;style type=<span class="string">&quot;text/css&quot;</span>&gt;</span><br><span class="line">div&#123;</span><br><span class="line">font-<span class="attr">size</span>:10px;</span><br><span class="line">&#125;</span><br><span class="line">div span&#123;</span><br><span class="line"><span class="attr">display</span>: inline-block;</span><br><span class="line">-webkit-<span class="attr">transform</span>:<span class="title function_">scale</span>(<span class="number">1.6</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="面试题：rem和em区别"><a href="#面试题：rem和em区别" class="headerlink" title="面试题：rem和em区别"></a>面试题：rem和em区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相对于font-size</span><br><span class="line"></span><br><span class="line">em针对于父元素的font-size</span><br><span class="line">rem针对于根(html)元素的font-size</span><br></pre></td></tr></table></figure><h4 id="面试题：ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉"><a href="#面试题：ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉" class="headerlink" title="面试题：ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉"></a>面试题：ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="selector-tag">a</span>,<span class="selector-tag">button</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>&#123;</span><br><span class="line">-webkit-tap-highlight-<span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="面试题：webkit表单输入框placeholder的颜色值能改变吗？"><a href="#面试题：webkit表单输入框placeholder的颜色值能改变吗？" class="headerlink" title="面试题：webkit表单输入框placeholder的颜色值能改变吗？"></a>面试题：webkit表单输入框placeholder的颜色值能改变吗？</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"><span class="selector-tag">input</span>::-webkit-input-placeholder&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="面试题：禁止ios长按时触发系统的菜单，禁止ios-amp-android长按时下载图片"><a href="#面试题：禁止ios长按时触发系统的菜单，禁止ios-amp-android长按时下载图片" class="headerlink" title="面试题：禁止ios长按时触发系统的菜单，禁止ios&amp;android长按时下载图片"></a>面试题：禁止ios长按时触发系统的菜单，禁止ios&amp;android长按时下载图片</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">禁止ios 长按时触发系统的菜单，禁止ios&amp;android长按时下载图片</span><br><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;</span><br><span class="line">touch-callout: none;</span><br><span class="line">-webkit-touch-callout: none;</span><br><span class="line"></span><br><span class="line">user-select:none;</span><br><span class="line">-webkit-user-select:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题：禁止ios和android用户选中文字"><a href="#面试题：禁止ios和android用户选中文字" class="headerlink" title="面试题：禁止ios和android用户选中文字"></a>面试题：禁止ios和android用户选中文字</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;</span><br><span class="line">user-select:none;</span><br><span class="line">-webkit-user-select:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题：自适应"><a href="#面试题：自适应" class="headerlink" title="面试题：自适应"></a>面试题：自适应</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">淘宝无限适配【移动端】：(引入淘宝的无限适配&#x27;js文件&#x27;)</span><br><span class="line">淘宝无限适配 + 布局单位使用rem</span><br></pre></td></tr></table></figure><h4 id="面试题：响应式"><a href="#面试题：响应式" class="headerlink" title="面试题：响应式"></a>面试题：响应式</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1. 是什么？</span><br><span class="line">一个URL可以响应多端</span><br><span class="line">2. 语法结构</span><br><span class="line">@media only screen and (max-width: 1000px)&#123;</span><br><span class="line">ul li:last-child&#123;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">only : 可以排除不支持媒体查询的浏览器</span><br><span class="line">screen ： 设备类型</span><br><span class="line">max-width | max-height   最大 宽度/高度</span><br><span class="line">min-width | min-height   最小 宽度/高度</span><br><span class="line">3. 响应式图片【性能优化】</span><br><span class="line"><span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">&quot;1.jpg&quot;</span> <span class="attr">media</span>=<span class="string">&#x27;(min-width:1000px)&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">&quot;2.jpg&quot;</span> <span class="attr">media</span>=<span class="string">&#x27;(min-width:700px)&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">&quot;3.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="布局方案"><a href="#布局方案" class="headerlink" title="布局方案"></a>布局方案</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一、什么情况下采用响应式布局</span><br><span class="line"></span><br><span class="line">数据不是特别多，用户量不是特别大，纯展示类的项目适合响应式布局</span><br><span class="line"></span><br><span class="line">例如：公司的官网、专题页面</span><br><span class="line"></span><br><span class="line">特别追求性能的项目，不太适合响应式，因为如果添加了很多的响应式就会造成加载速度变慢。</span><br><span class="line"></span><br><span class="line">二、pc + 移动端应该做什么样的布局方案</span><br><span class="line">注意：访问量还可以或者比较大，类似于淘宝网。</span><br><span class="line"></span><br><span class="line">pc是一套，会加入一点点响应式。</span><br><span class="line">移动端是一套，会使用自适应的布局方式。</span><br><span class="line"></span><br><span class="line">三、pc的设计图</span><br><span class="line"></span><br><span class="line">ui：1980</span><br><span class="line">笔记本电脑：1280</span><br><span class="line">ui图的宽度和电脑的宽度不对应该怎么办？</span><br><span class="line">1. 把ui图进行等比缩放，缩放成和电脑一样的尺寸</span><br><span class="line">2. 换1980的电脑</span><br><span class="line"></span><br><span class="line">四、移动端的设计图</span><br><span class="line"></span><br><span class="line">宽度：750</span><br><span class="line">因为750设计图/2就是375，正好是iphone6的尺寸，我们要把iphone6的尺寸做为基准点。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;HTML面试题&quot;&gt;&lt;a href=&quot;#HTML面试题&quot; class=&quot;headerlink&quot; title=&quot;HTML面试题&quot;&gt;&lt;/a&gt;HTML面试题&lt;/h3&gt;&lt;h4 id=&quot;面试题：行内元素有哪些？块级元素有哪些？-空-void-元素有哪些？&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="前端" scheme="https://lcl.shiqi217.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="HTML CSS" scheme="https://lcl.shiqi217.com/tags/HTML-CSS/"/>
    
  </entry>
  
  <entry>
    <title>ES6面试题</title>
    <link href="https://lcl.shiqi217.com/2022/09/05/%E5%89%8D%E7%AB%AF/ES/"/>
    <id>https://lcl.shiqi217.com/2022/09/05/%E5%89%8D%E7%AB%AF/ES/</id>
    <published>2022-09-05T11:26:09.000Z</published>
    <updated>2022-11-06T13:52:11.316Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ES6面试题"><a href="#ES6面试题" class="headerlink" title="ES6面试题"></a>ES6面试题</h3><h4 id="面试题：var、let、const区别"><a href="#面试题：var、let、const区别" class="headerlink" title="面试题：var、let、const区别"></a>面试题：var、let、const区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var、let、const 共同点都是可以声明变量的</span><br><span class="line"></span><br><span class="line">区别一：</span><br><span class="line">var 具有变量提升的机制</span><br><span class="line">let和const没有变量提升的机制</span><br><span class="line">区别二：</span><br><span class="line">var 可以多次声明同一个变量</span><br><span class="line">let和const不可以多次声明同一个变量</span><br><span class="line">区别三：</span><br><span class="line">var、let声明变量的</span><br><span class="line">const声明常量</span><br><span class="line"></span><br><span class="line">var和let声明的变量可以再次赋值，但是const不可以再次赋值了。</span><br><span class="line">区别四：</span><br><span class="line">var声明的变量没有自身作用域</span><br><span class="line">let和const声明的变量有自身的作用域</span><br></pre></td></tr></table></figure><h4 id="面试题：作用域考题"><a href="#面试题：作用域考题" class="headerlink" title="面试题：作用域考题"></a>面试题：作用域考题</h4><h5 id="考题一：let和const没有变量提升性"><a href="#考题一：let和const没有变量提升性" class="headerlink" title="考题一：let和const没有变量提升性"></a>考题一：let和const没有变量提升性</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str );<span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;你好&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( num );<span class="comment">//报错</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>考题二：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">demo</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>( <span class="literal">true</span> )&#123;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( n );<span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">demo</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">demo</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>( <span class="literal">true</span> )&#123;</span><br><span class="line"><span class="keyword">let</span> n = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( n );<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">demo</span>();</span><br></pre></td></tr></table></figure><p>考题三：可以修改</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"><span class="attr">a</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">a</span> = <span class="number">11111</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj )</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">arr[<span class="number">0</span>]= <span class="string">&#x27;aaaaa&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( arr );</span><br></pre></td></tr></table></figure><h4 id="面试题：将下列对象进行合并"><a href="#面试题：将下列对象进行合并" class="headerlink" title="面试题：将下列对象进行合并"></a>面试题：将下列对象进行合并</h4><p>方式一：Object.assign</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;<span class="attr">b</span>:<span class="number">2</span>,<span class="attr">c</span>:<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(a,b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1 );</span><br></pre></td></tr></table></figure><p>方式二：…</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = &#123;...a,...b&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj2 );</span><br></pre></td></tr></table></figure><p>方式三：自己封装方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">extend</span>(<span class="params"> target,  source </span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source)&#123;</span><br><span class="line">target[key] = source[key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">extend</span>(a,b) );</span><br></pre></td></tr></table></figure><h4 id="面试题：箭头函数和普通函数有什么区别？"><a href="#面试题：箭头函数和普通函数有什么区别？" class="headerlink" title="面试题：箭头函数和普通函数有什么区别？"></a>面试题：箭头函数和普通函数有什么区别？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. this指向的问题</span><br><span class="line">箭头函数中的this只在箭头函数定义时就决定的，而且不可修改的（call、apply、bind）</span><br><span class="line">****箭头函数的this指向定义时候、外层第一个普通函数的this</span><br><span class="line">2. 箭头函数不能new（不能当作构造函数）</span><br><span class="line">3. 箭头函数prototype</span><br><span class="line">4. 箭头函数arguments</span><br></pre></td></tr></table></figure><h4 id="面试题：Promise有几种状态"><a href="#面试题：Promise有几种状态" class="headerlink" title="面试题：Promise有几种状态"></a>面试题：Promise有几种状态</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有三种状态：</span><br><span class="line">pending（进行中）</span><br><span class="line">fulfilled（已成功）</span><br><span class="line">rejected（已失败）</span><br></pre></td></tr></table></figure><h4 id="面试题：find和filter的区别"><a href="#面试题：find和filter的区别" class="headerlink" title="面试题：find和filter的区别"></a>面试题：find和filter的区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">区别一：返回的内容不同</span><br><span class="line">filter 返回是新数组</span><br><span class="line">find   返回具体的内容</span><br><span class="line">区别二：</span><br><span class="line">find ：匹配到第一个即返回</span><br><span class="line">filter ： 返回整体（没一个匹配到的都返回）</span><br></pre></td></tr></table></figure><h4 id="面试题：some和every的区别"><a href="#面试题：some和every的区别" class="headerlink" title="面试题：some和every的区别"></a>面试题：some和every的区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">some  ==》 如果有一项匹配则返回true</span><br><span class="line">every ==》 全部匹配才会返回true</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;ES6面试题&quot;&gt;&lt;a href=&quot;#ES6面试题&quot; class=&quot;headerlink&quot; title=&quot;ES6面试题&quot;&gt;&lt;/a&gt;ES6面试题&lt;/h3&gt;&lt;h4 id=&quot;面试题：var、let、const区别&quot;&gt;&lt;a href=&quot;#面试题：var、let、const区</summary>
      
    
    
    
    <category term="前端" scheme="https://lcl.shiqi217.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="ES" scheme="https://lcl.shiqi217.com/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>你未必光芒万丈，但始终温暖有光🎈💫</title>
    <link href="https://lcl.shiqi217.com/2022/09/05/%E9%82%A3%E4%BA%9B%E4%BA%8B/2022%E5%B9%B49.5/"/>
    <id>https://lcl.shiqi217.com/2022/09/05/%E9%82%A3%E4%BA%9B%E4%BA%8B/2022%E5%B9%B49.5/</id>
    <published>2022-09-04T19:17:17.000Z</published>
    <updated>2022-10-25T10:36:07.439Z</updated>
    
    <content type="html"><![CDATA[<div class='wow animate__flip' data-wow-duration='' data-wow-delay='' data-wow-offset=''  data-wow-iteration='' ><div class="note green icon-padding modern"><i class="note-icon fas fa-fan"></i><p>本来准备修完一些bug就直接进入我的梦乡，想想还是写一下今天的大概✍️ </p></div></div><pre><code>必须养成良好习惯不是？😊 也就随便写写</code></pre><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>白天呢，开始疯狂的补充自己的知识量🤔</p>            </div><pre><code>晚上才有空来维护一下自己的小空间，之间总觉得时间过得挺慢的，但是慢慢的发现，现在的时间越来越不够用了，现在 想想，过去的自己在慢慢的成长，体会生活。</code></pre><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>添加了右键菜单 (但功能还需要继续增添修改🤔)</p>            </div><p>修复添加了一些 微博热点啥的。刚开始还是得多学习，多查阅，多理解 从新手慢慢就练成”老匠” (<psw>代码CV农</psw>)</p><p>今天时间太晚了，偷个懒，发篇摘抄的短文吧，</p><div class="tip sync"><p>男孩是在回家的途中认识女孩的。　　他不会忘记那个晴朗的午后，温柔的阳光透过柳树的枝条，投下一片夺目的光彩。女孩一个人静静的坐在没有青草的草坪上，描绘着眼前的那座一百多年历史的老教堂。　　她的眼神显得很凝重，很有一种历史的沧桑感。竟令男孩不自觉的停下了步伐，呆呆的看着入了神。　　好一阵子，一个声音在耳边忽然响起：“你，有什么问题吗？”　　凝重的眼神与声音，是女孩。　　“哦，没……”　　“没事的话请不要看……”　　女孩转过身，再没有话语，继续自己的事情。男孩一个人呆呆的站在原地，有些难以置信。　　以后的日子，一连几天下学的时候，在那片空空的草坪上，男孩总可以看到女孩的身影。依然一个人，依然画着沧桑的教堂，不变的依然是凝重的神情以及冷冷的眼神。　　男孩每天经过的时候，也总要莫名其妙停一会。已经习惯了远远的看着女孩的背影，然后再悄悄的离开。女孩似乎有什么神秘的气息，一直牵引着男孩的心。可是男孩却始终也没有勇气走上去和她搭句话。　　那一天，天空飘起了入冬以来的第一场雪，沸沸扬扬的飘洒在漫天。男孩依然习惯的走过草坪，忽然发现女孩不见了。心头竟然莫名其妙的有些伤感了起来。　　或许，是她已经完成了她的作品了吧。男孩想，看着女孩曾经坐过的地方竟然不自觉的走了过去。　　那似乎是一个圣地，令男孩神往的圣地。　　刚要坐下，忽然背后传来了一个熟悉而又陌生的声音，低沉的：“对不起，这是我的地方，你应该知道。”　　这个……是女孩！男孩激动的回过头，果然，是那个画画的女孩，那个有着冷漠的眼神、凝重的表情的女孩。　　那个心中想念的女孩，心中一直神往的女孩。　　“对不起，我……”　　“请你让开……”女孩很不客气的推开了眼前的人。　　“还要画画？”男孩问。　　“怎么了？”　　“可是下雪了呀。”　　“或许可以看到红色的雪。”　　“红色？”　　女孩转过脸，对着男孩说了一句令他永生难忘的话：“记住，只有真心相爱的人才有机会看到红色的雪。”　　男孩一楞。　　女孩又沉默了下来，一个人描绘起了眼前的古老的教堂以及那些古老的梧桐树。她的眼神似乎和这个奇怪的建筑一样的古老，令人神往而又肃穆的神情。　　男孩也没有说话，只是静静的站在她的身后。雪漫无边际的纷纷落了下来，仿佛纷飞的白玫瑰花瓣，落在了女孩的身上，头发上。女孩仿佛一个神秘的女神，全身上下一片银白色。很凄然，美丽。　　男孩呆呆的审视着眼前的女孩，也不知道有多久，忽然发现女孩一直没有动。无论他去怎么叫也叫不醒。　　当她醒来的时候已经是医院了，朦胧的视野中现出了男孩的面容。　　“你把我送到了医院？”女孩问。　　“是。”男孩回答。　　“谢谢。”还是那样的简练，似乎是比这个冬天还要冷。可是男孩已经习惯了，他知道，其实她的心并不像想象的那样坚定，因为……　　“你看了我的病历了？”女孩忽然说。　　“是……”　　“那你知道了？”　　“是……”　　“先天性的，医生说我最多还有一年的时光。”女孩说这些的时候很平静，“其实这样也没什么不好。在这个世界上我已经没有什么可留恋的了……”　　“没有什么办法吗？”男孩问。　　“心脏病，没有办法。”还是很平静，似乎死亡已经是身外的事物。或许，是她已经习惯了提心吊胆的日子，或许，是已经习惯了等待死神的那份从容。　　可是，这些话在男孩听来却想哭。　　无数次的，在噩梦醒来的时候，眼泪朦胧了一切。他忽然觉得自己原来已经喜欢上了女孩，喜欢每天走过公园的草坪看着一个身影静静的描绘着四周的景色。他会驻足观望，有时会拿些零食两个人一起吃。　　“知道吗？这个世界是丰富多采的，很多的幸福我们都还没有看到。”男孩说。女孩很沉默。　　“总有一天你会看到属于你的红色的雪花的。”　　整个冬季飘扬着雪花。　　男孩每天放学的时候会准时的牵起女孩的手一起看着飘落的白雪，纷纷扬扬的雪映照着血一样的夕阳，很凄惨。女孩依旧喜欢画画，喜欢画风景，喜欢画雪，喜欢画红色的雪。</p></div><div class="tip home"><p>晚安，好梦💫,明天依然在</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&#39;wow animate__flip&#39; data-wow-duration=&#39;&#39; data-wow-delay=&#39;&#39; data-wow-offset=&#39;&#39;  data-wow-iteration=&#39;&#39; &gt;&lt;div class=&quot;note green icon</summary>
      
    
    
    
    <category term="生活" scheme="https://lcl.shiqi217.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://lcl.shiqi217.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>故事不长，也不难讲，相识一场，爱而不得</title>
    <link href="https://lcl.shiqi217.com/2022/09/05/%E4%B9%A6%E5%86%99%E8%BF%87%E5%8E%BB/%E6%95%85%E4%BA%8B/"/>
    <id>https://lcl.shiqi217.com/2022/09/05/%E4%B9%A6%E5%86%99%E8%BF%87%E5%8E%BB/%E6%95%85%E4%BA%8B/</id>
    <published>2022-09-04T16:02:17.000Z</published>
    <updated>2022-11-15T11:08:39.747Z</updated>
    
    <content type="html"><![CDATA[<!-- <a href="javascript:;" onclick="randomPost()" title="随机访问一篇文章">随机</a> --><div class='wow animate__flip' data-wow-duration='' data-wow-delay='' data-wow-offset=''  data-wow-iteration='' ><div class="note green icon-padding modern"><i class="note-icon fas fa-fan"></i><p>明知不可为而为之是我最大的诚意🧑👧</p></div></div><div class="tip info"><p>相识</p></div><p>男孩在高中的时候，算是一个网瘾少年，但是在寒假的某一天傍晚，他在网上通过游戏结识了一个女孩，她那时初三，男孩抱着交朋友的心态开始和那女孩玩游戏，一局又一局的打，后来加上了女孩的qq，开始聊天，相互了解对方，<br>慢慢地，男孩在心里对她产生了些许情愫。随着时间的 推移，这种情愫越来越大，慢慢地在他心里占据一席之地。</p><div class="tip success"><p>相爱</p></div><p>开始主动的与她聊天，… 在那个女孩生日那天，他终于忍不住心里的那种特殊的 感情，对她进行了表白，刚开始她还挺惊讶，不是很愿意（可能是因为距离/相识时间，又或者是网恋等等），架不住男孩的死缠烂打，她也是同意了，当天把男孩激动地不行，<br>男孩慢慢的开始和她打电话，打视频。可能是随着时间的增加，女孩接受了男孩。<br>开始了情侣中的热恋期。可是架不住现实，两人各自回归了学校的生活，<br>男孩之前自己存着钱买了一部手机。偷偷摸摸的带到学校。女孩的手机带到学校需要上交给他们的老师，且只能在每一个星期天的下午发放。男孩也是每天等着她上线和他回句信息。这样的日子持续了一个个暑假寒假，<br>男孩骗她说自己学习挺好的，但是随着日子慢慢过去，男孩在高三那年，他的老师说单招可以比高考提前三个月离校。男孩学习不好，他瞒着女孩，选择了单招，<br>单招回到家，和他的同学一起去打工。男孩想赚钱去见女孩，在去往厂里的那天晚上。他向女孩坦白了自己的事情，女孩没有责怪他，说：以后不许骗我。不管你什么样我都会陪在你身边，男孩看到女孩发的信息，眼眶有些湿润。哽咽的回了她…..</p><p>到了厂里，他不幸的分配到了夜班，第一天晚上去上班的时候，在流水线上，前几个小时还有些精神，过了两三点的时候，男孩眼睛就快睁不开了，他看了看旁边，有一个橡皮筋，弹在的他的胳膊上 ，清醒了一些，又开始工作，慢慢的皮筋不是很管用了，他也快睡着了，心中狠下心，开始拧自己胳膊，坚持到了下班，他看了看胳膊上的青块，心中烦躁。慢慢的，他逐渐的适应了夜班，就这样边工作边等星期天的到来，<br>女孩也是每次星期天那天拿到手机就和男生发信息，打视频。女孩给男孩编了手链。男孩收到24小时待在手上。<br>男孩因为是夜班，每次星期天，下班回到宿舍就会先补充睡眠，睡觉时时间会过的快一点吧，因为定了闹钟，很少在女孩发信息的之后晚回，这样过了半个月，<br>临近男孩的生日的时间越来越短了，女孩偷偷买了一个生日礼物提前寄给了男孩，和男孩说了：你记得拿快递，至于礼物是什么没和男孩说，男孩就开始等快递的到来，生日前的第二天，男孩收到了快递发来的短信，怀着激动的心情去快递那边领取，拿到就迫不及待的打开，发现是一个打火机，然后拍照和她说自己很喜欢，（礼物不在乎贵重，在乎的是这是喜欢的人送给你的）男孩当时不抽烟，后来才知道女孩上网上看到送男朋友可以送打火机，她定制了带有他们两个的名字的黑色打火机。<br>男孩生日那天是星期天，女孩正好在家，虽然生日的时候在厂里。但是男孩很满足。因为生日这天至少还有女孩陪伴他。往后的日子，<br>男孩每天都是带着身边…..<br>直到有一天休息。男孩的朋友们拉着他去通宵。男孩架不住。和他们去玩了一夜。到了早上回去时。回到住处男孩发现带在身边的打火机消失了，应该是晚上在网吧落在了那边。于是又打了车去那边寻找。可是还是没能找到。他只能和老板说如果找到了请联系他之类的话，老板也是敷衍的回了他。回到住处。就和女孩说了这件事。等到女孩星期天的时候。看到了他发的信息。安慰他说没事什么的。只是。这个打火机对他来说很重要。自己偷偷怨自己大意。。。。</p><p>男孩也许是第一次出去打工，还是夜班太累。便产生了一些退缩。加上朋友对他说自己快走了。让男孩慢慢坚定了离开这里的想法。可进厂没有他想的那么简单。以为干完走之前就可以吧工资结了。按照厂区的规定。压一个月的工资。所以直到男孩回去，也是没有实现自己找女孩的事，<br>回去后，男孩就去学了驾照。两人的关系也越来越好。这样的日子持续到了第二年……</p><p>在女孩暑假时，男孩买了去找她的火车票。坐了25个小时来到了她生活的地方。去了女孩的镇上。当到女孩镇上的时候已经是天黑了，女孩知道男孩还没吃饭，给她推荐了一个好吃的饭点，让他去填饱肚子。那是男孩第一次吃螺蛳粉。边吃边和她讲好吃，还说下次和女孩一起来。回到了住的地方。怀着激动的心情过去了一晚，第二天女孩要去找男孩，男孩把房间的门留了一个缝，等女孩来到他住的地方，男孩躺在床上让她自己进去，女孩害怕。男孩站起身就去开门。打开了，看到了自己朝思暮想的人，立刻拥抱了她，搂着她进了屋子。呆了一会。女孩带着她去了超市。女孩喜欢吃辣条。但是身体原因，男孩只能买点甜点的东西，和酸奶。出去超市，女孩要去买菜。男孩就在那边等着。来回转转。买完了，想找男孩。却看不到他。男孩看着她傻傻的样子。开心的笑了。向她招了招手。牵着手回去了。到了住的地方，酸奶有点凉。男孩怕女孩肚子痛。就用宾馆的热水壶煮了点热水，等到酸奶热点了才给她打开喝。那时候是男孩最开心的时候。可是这样的日子虽然很开心，但是过得还是挺快的，一眨眼。就到了男孩回去的日子了。提前两天订的飞机票。最后一天也没和女孩见最后一面。(女孩出不去)，带着不开心的脸坐上了回家的路。<br>往后的日子也是这样一直过得，有开心，也有过吵架。但像两个人有默契一样。从来没说过分手。知道女孩身体弱，每次都是给她寄牛奶补充一下。～，</p><p>在男孩心里已经内定了女孩就是他的唯一。</p><p>到了第二次见面时。也就是那年的最后一天，<br>那天30号，男孩怀着期待和开心坐上了去往她那边的飞机，同样是奔波了一天。晚上去了网咖呆了一晚。因为31号女孩下午放假。第二天中午男孩找了一个酒店。收拾好了就去了她的学校。由于路上接孩子的家长太多了。车子慢吞吞的走着。他心里也越来越期待。到了学校门口。男孩给女孩打视频问她在哪。女孩说收拾好就出去。男孩在那边焦急的等着。没等一会，女孩收拾好说她准备出去了。男孩就在门口看。功夫不负有心人，男孩看到了女孩，女孩还傻傻的去找男孩，直到走到男孩跟前。才看到。接到女孩，牵着手去了附近的超市。买了一些零食。在超市，男孩还向他朋友炫耀女孩。买完打了个车去了酒店。到了酒店就抱着女孩。可能太想她了吧，女孩还怪男孩没帮她背着书包。男孩就连忙道歉。一会，带着女孩扫了一个电动车，去了公园，拍了照片。休闲的散步。晚上去了超市买了一些水果。男孩恨不得这样的时间过得慢一点，一直待在女孩身边。就这样过了4天三夜。直到女孩开学。男孩才恋恋不舍的。拖一些时间。直到傍晚才送到学校。当女孩进去学校的那一刻。男孩心里失落落的。挎着身躯漫无目的的走着，想到女孩还没吃饭去了。就准备在网吧待会，准备到了晚自习下课的时候。买点吃的带给她吃。<br>临近下课。就和她朋友发信息(上课之前就已经交了手机。)说让她来学校门口。女孩她朋友下课去她班级找她，可是她去厕所了。等到几分钟。女孩回去了，她朋友就告诉她男孩在门口等着你，男孩在门口焦急的等着。门卫大爷在那看着男孩。男孩眼见快上课了。就想着放在门卫大爷那边，门卫大爷让男孩给她班主任打电话。可是班主任没接。就写了个纸条放在了那上面。准备离开的时候，看见女孩急速的走过来。男孩连忙把饭递给了她。说了会话。女孩听到上课铃响了。就回去了。男孩嘱咐了一下。也就也离开了。回到酒店。心不在焉的，失落落的。<br>第二天，男孩就回去了。等到女孩星期天发手机的时候。给男孩说。她好想男孩。天天下了晚自习就趴在被窝里写日记。写想给男孩说的话。还把日记拍给男孩看。男孩感动的不行…..</p><div class="tip key"><p>相离</p></div><p>这样的日子维持到了六月份，男孩知道女孩手机不好用。暑假准备努力工作，多赚点钱去找她，顺便带她买部手机用，就跟着朋友去了北京做了一名打工人。因为想要多挣一点。在签合同的时候就签了时间长的工作，只为了多挣点。从入职到结束，男孩心里怀有期待。催促着这个月赶紧过得快一点，第一个星期天就发生了一件事<br>女孩星期天，男孩和女孩吵了架。女孩改了密码。直到女孩收手机也没有解决。<br>男孩吵完就后悔。不该这样对待女孩，和女孩发了好多信息。虽然知道她回不了。<br>临近第二天晚上。因为男孩和女孩的qq已经火花已经礼拜天了。每天都是靠着男孩维持的。尽管没什么用。但是男孩心里全是有点慰藉，但是那天因为女孩没给他密码。男孩不想让火花消失。直接就擅作主张把女孩的密码改了。等到下一个星期天。女孩发了手机。发现了这件事。用v和男孩发信息让他把密码给她。不知道是因为这一次的事还是上一次的事情。女孩说了，我们聊聊吧。男孩因为工作原因没办法看手机。知道那天女孩发手机，特意提前和他朋友说让他帮忙干一下他的工作。即使这样。下午还是有两个小时要忙，趁着工作没什么人。就偷偷打开手机和女孩道歉并说明原因。女孩说我们好好聊聊吧。可能男生嘴都比较笨。回的总是一些道歉的话。等到男孩下班，躺在床上。和女孩打视频也没接。女孩说，我们分手吧。男孩有些诧异。连忙问他为什么。女孩也不肯说。在男孩的问下，女孩说了不合适，距离等等，最后还有句不爱了。男孩当时魂就丢了。失魂落魄的坐起来。女孩把他删了。随之男孩发微信，打电话，发短信，女孩也没改变自己的决定。<br>等到男孩朋友下班，发现男孩心情不好，就问了他。随后知道了这件事，男孩默默的起来。去了超市买了盒烟。坐在地面默默的抽了一根又一根。男孩朋友也去了。坐在他旁边劝他。默默的陪着男孩。男孩说。我想去找她。就算分手，也想再见见，万一有可能和好呢。抱着这个希望，男孩的朋友劝他，等到这个月结束，发完工资再去。男孩想了想，也是同意了。<br>以后的日子，男孩魂不守舍的干着工作。下班的时候总是在地面出神的坐着，手上的烟也没有掉过。想起之前的日子，直到烟火躺着男孩了。男孩默默的扔掉它，从烟盒里拿出一根又默默的点上，工作的时候总是出神的想起和女孩的点点滴滴。那么多美好，最终现实是残酷的。一下下把男孩打回现实。这样的日子终于过去了。男孩提前订了飞机票。想要赶紧去她那里。因为去女孩那里要来回转车。先坐完飞机，再赶到火车站做火车。<br>那天男孩早早的起来。默默的收拾东西。从分手以后，男孩的话就很少了。天天都是吃很少的饭。抽很多的烟。去了公司领完工资。跟朋友道别之后就去了机场。坐上了去往女孩那边的路<br>等男孩下飞机。连忙坐上去往火车站的路上。路上。和女孩的朋友说快到她们那边了。刚到火车站。就发现有一个陌生人添加他。让男孩别去找她了。那个男的说是女孩的好朋友。男孩心里知道大概是谁。也知道男孩对女孩有好感。气顶到头顶，让男孩开始就对他骂。说，喜欢她就光明正大的表达，这样畏畏缩缩的算什么。。。。<br>想和这个男孩约架，那个男孩也不约。男孩没办法，只能先去找她，晚上到了女孩的镇上。还是她们第一次见面的宾馆。和女孩的女性朋友发信息说见一面吧。架不住男孩，<br>女孩朋友问了女孩。女孩说明天吧。女孩的朋友就和男孩发了过去。男孩也没什么事。就去了女孩的村子里。因为女孩家在村口，所以就大概能看到。默默的蹲着抽起了烟。眼泪掉了下来，回到宾馆，男孩一夜没睡，<br>因为是下午见面，上午男孩早早的起来了，去他们曾经去的地方。安安静静的走着。下午简单收拾了一下。就去了他们约的地方。女孩在那边静静地坐着。神情也不是很好。男孩默默的走到她旁边。坐了下来。开始哄女孩，道歉。说着说着。眼泪就出来了。女孩也许也是想到了之前的美好。也是流了泪。男孩拿着送给女孩的手表(因为在之前女孩的手表不能用了)，想要给女孩戴上。女孩不同意，男孩想握着女孩的手。女孩把手抽了出来。拿纸擦眼角的眼泪。男孩说着说着。可能是悔恨。难过。不知不觉的，他的手就在手腕上扣了一块肉。女孩看到连忙阻止男孩。女孩也是不准备再复合。。。。<br>慢慢地。过了一个多小时。女孩想离开。男孩知道一切都回不去了。也没阻止她。随后酿酿跄跄的出了奶茶店。去了附近买了瓶酒。回到那家店对面，坐在台阶上喝了起来。没一会。女孩出来了。她朋友准备骑车。没扶好车子倒在了地上。男孩连忙扔掉酒，跑过去帮她扶起来。女孩的朋友说了句谢谢。男孩点了点头。说了句路上注意安全。就转头失落的走了。又去店里买了6瓶酒。提着去了曾经他们第一次见面的宾馆。<br>回去默默的喝着。等到半夜，男孩才在泪水中睡了过去。第二天早上，男孩起床，想着再去看看她，女孩不同意。男孩就和她朋友要了她家的位置，去了她的村口。在村牌那边坐着，看着女孩的家，默默的抽着烟，女孩的朋友和女孩说了男孩在村口。女孩也不知道从窗户看了没看男孩。男孩一直呆到了中午。女孩和她朋友说让他回去。因为下午的火车。女孩的朋友和男孩说了以后，正好要去镇上。路过女孩的村口。去见了男孩一面。安慰了男孩。让男孩回去。男孩点了点头。向女孩家那个方向望去。弯腰鞠了一躬。就坐上了去镇上的车。提着行李箱去了火车站。可能是想慢慢的离开。做了一天的火车。由于男孩饿的太狠。走着路随时就像倒了一样。酿酿跄跄的走着。坐在火车里。眼神看向了女孩那边的方向。默默的看着。。。。<br>回到了男孩那边。约了几个朋友去喝了酒。配着烟默默的喝着。之前男孩不抽烟。自从发生了这件事之后，男孩像是有烟瘾了一样。接连不断的抽着。男孩的朋友不忍心让男孩一直颓废下去。就说要去找工作。男孩也答应了。因为被中介骗了，把行李扣押在了那个公司里面。刚好那时候，市区发了洪水。停水停电，男孩在楼下待了两天两夜，好不容易公司的人来了。才拿到行李。回了他朋友的家。呆了几天。又去了北京。只不过这两次的目的是完全不一样。签了一个最少的工作。每次都是早点回去。买了酒。买了烟。坐在外面默默的抽着。的朋友陪着他。每次夜里都是失眠，看着小说。还一两点才睡。吃饭保证自己饿不死就行。这样过去了一个月。这一个月几乎全靠着酒维持着男孩的生命。虽然男孩和女孩已经分手了。但是每天都是发着信息。即使女孩已经拉黑了他。。。。</p>]]></content>
    
    
    <summary type="html">错过了落日余晖，还可以静待满天繁星</summary>
    
    
    
    <category term="书写过去" scheme="https://lcl.shiqi217.com/categories/%E4%B9%A6%E5%86%99%E8%BF%87%E5%8E%BB/"/>
    
    
    <category term="生活" scheme="https://lcl.shiqi217.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>一场梦</title>
    <link href="https://lcl.shiqi217.com/2022/09/03/%E4%B9%A6%E5%86%99%E8%BF%87%E5%8E%BB/%E4%B8%80%E5%9C%BA%E6%A2%A6/"/>
    <id>https://lcl.shiqi217.com/2022/09/03/%E4%B9%A6%E5%86%99%E8%BF%87%E5%8E%BB/%E4%B8%80%E5%9C%BA%E6%A2%A6/</id>
    <published>2022-09-03T01:40:54.000Z</published>
    <updated>2022-10-25T11:20:41.316Z</updated>
    
    <content type="html"><![CDATA[<div class='wow animate__flip' data-wow-duration='' data-wow-delay='' data-wow-offset=''  data-wow-iteration='' ><div class="note green icon-padding modern"><i class="note-icon fas fa-fan"></i><p>✍️今天做了一个很特别的梦，虽然梦中的发展不是很完美。🙃</p></div></div><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/wenzhang/lcl2.jpg" style="width:400px height=300px;"/></div></div><p class='p cyan'>梦中画面</p><p>刚好有事情要去她那边(<psw>连我做梦都不知道什么事，只是穿越到了那边</psw>)。<br>就想去看看她，弥补当初留下的遗憾。<br><div class="tip info"><p>当我再次等到她一个人去学校的时候，我心里是忒激动啊。想冲上去抱着她，可是理智让我没有表达出来。</p></div></p><p>我缓缓走到她面前，说：<span class='p green'>好久不见</span>。她回了一句，就离开了。我愣在了原地，(抱歉，我都蒙蔽了，我怎么会说这种话，太离谱了)</p><p>只到她离开我的视线，我愣是没回过神来。刚想离开。我心想：我他喵的想要弥补，而不是打个招呼而已。要给她追过来。就带着我的朋友(朋友不是编造出来，而是梦中真的有😭)，跑到了她们学校里。当我到她所在的班里的时候刚开始上课。<br>我在她班级外面看着这个 让我十分想念的人。(切记，这不是猥琐，是思念)<br>上课途中我通过wx问了一个她的朋友<span class='p red'>qrt</span>。什么时候下课之类的。收到答案以后，然后就在班级外面开始了漫长的等待和煎熬，<br>突然她们老师看见了我。慢慢的，有些同学也看向我。而我盯着朝思暮想的她，没说话，只是点了点头。<br>可能是因为老师怕打扰到学生。就给我挥了挥手让我离开。可是好不容易的相见。怎么能空着回去呢。就直接绕道她们班级前面。坐着出神的等待下课的铃声~…..</p><p>等了不知多久。低头看了看时间。发现已经到了下课的时间。我连忙跑到他们班级门口。呼喊她的名字。<br>她抬头看向我。脸上有些许失落(不知道什么原因，梦中的表情是这样)。<br>我拉着她拉到了一片安静的地方。向她倾诉着一些事情。她也跟我讲了一些之后的事。我趁机要和她<psw>表达心意</psw>。可她还是婉转的拒绝了我。  过了这一次，可能就没有下一次了。我等了一年了。这次见面以后都是未知数。最终她还是回去了，</p><p>而我，也回到了现实(梦也惊醒了)，醒了久久不能忘怀，靠着床头，静静地抽了一根烟。思考了许久，还是得面对现实的残酷。<br>有时候我会想，如果我出生在她那边，或者她在我这边。可能结果会不一样。<br>如果我们晚几年相遇，结果可能也是不一样，可是哪有那么多如果呢。慢慢的还是只能接受现实。😖(现实太他喵的残酷了叭)</p><div class="img-wrap"><div class="img-bg"><img class="img" src="/img/wenzhang/lcl1.jpg" style="width:400px height=300px;"/></div></div><div class="tip fa-atom"><p>特此声明，一切只是梦 😖 ——小王</p></div><p>短暂的思考，最终决定把这个梦的记录到我的时候博客上来。当做是对往事的她一个怀念吧。<br>有太多不舍，不甘….到最后却只能怀念你 (悲催的人生),<br><del>默默的抽烟缓解心情呜呜😭</del></p>]]></content>
    
    
    <summary type="html">此情有憾，然无对错</summary>
    
    
    
    <category term="书写过去" scheme="https://lcl.shiqi217.com/categories/%E4%B9%A6%E5%86%99%E8%BF%87%E5%8E%BB/"/>
    
    
    <category term="生活" scheme="https://lcl.shiqi217.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>关于Twikoo的部署</title>
    <link href="https://lcl.shiqi217.com/2022/09/02/hexo/%E5%85%B3%E4%BA%8ETwikoo%E8%AF%84%E8%AE%BA%E9%85%8D%E7%BD%AE/"/>
    <id>https://lcl.shiqi217.com/2022/09/02/hexo/%E5%85%B3%E4%BA%8ETwikoo%E8%AF%84%E8%AE%BA%E9%85%8D%E7%BD%AE/</id>
    <published>2022-09-02T13:02:17.000Z</published>
    <updated>2022-10-19T11:59:52.962Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>进入<a href="https://curl.qcloud.com/KnnJtUom">云开发CloudBaseopen in new window</a>活动页面，滚动到“新用户专享”部分，选择适合的套餐，点击“立即购买”，按提示创建好环境。</p><div class="tip success"><p>​            提示</p><p>​                推荐创建上海环境。如选择广州环境，需要在 <code>twikoo.init()</code> 时额外指定环境 <code>region: &quot;ap-guangzhou&quot;</code></p><p>​                环境名称自由填写</p><p>​                推荐选择计费方式<code>包年包月</code>，套餐版本<code>基础版 1</code>，超出免费额度不会收费</p><p>​                如果提示选择“应用模板”，请选择“空模板”</p></div><p>​    </p><p>2.进入<a href="https://console.cloud.tencent.com/tcb/">云开发控制台open in new window</a></p><p>3.进入<a href="https://console.cloud.tencent.com/tcb/env/login">环境-登录授权open in new window</a>，启用“匿名登录”</p></li><li><p>进入<a href="https://console.cloud.tencent.com/tcb/env/safety">环境-安全配置open in new window</a>，将网站域名添加到“WEB安全域名”</p></li><li><p>进入<a href="https://console.cloud.tencent.com/tcb/scf/index">环境-云函数open in new window</a>，点击“新建云函数”</p></li><li><p>函数名称请填写：<code>twikoo</code>，创建方式请选择：<code>空白函数</code>，运行环境请选择：<code>Nodejs 10.15</code>，函数内存请选择：<code>128MB</code>，点击“<span class='p red'>下一步</span>”</p></li><li><p>清空输入框中的示例代码，复制以下代码、粘贴到“函数代码”输入框中，点击“确定”</p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">main</span> = <span class="built_in">require</span>(<span class="string">&#x27;twikoo-func&#x27;</span>).<span class="property">main</span></span><br></pre></td></tr></table></figure><ol><li><p>创建完成后，点击“twikoo”进入云函数详情页，进入“函数代码”标签，点击“文件 - 新建文件”，输入 <code>package.json</code>，回车</p></li><li><p>复制以下代码、粘贴到代码框中，点击“保存并安装依赖”</p></li></ol><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;twikoo-func&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.6.7&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/img/wenzhang/1.t2.png" alt=""></p><h4 id="在-Hexo-Butterflyopen-in-new-window-主题使用"><a href="#在-Hexo-Butterflyopen-in-new-window-主题使用" class="headerlink" title="在 Hexo Butterflyopen in new window 主题使用"></a>在 <a href="https://github.com/jerryc127/hexo-theme-butterfly">Hexo Butterflyopen in new window</a> 主题使用</h4><p>请参考 <a href="https://butterfly.js.org/posts/ceeb73f/#評論">Butterfly 安裝文檔(四) 主題配置-2open in new window</a> 进行配置</p><p><img src="/img/wenzhang/1.t1.png" alt=""></p>]]></content>
    
    
    <summary type="html">本文章只有腾讯云的部署</summary>
    
    
    
    <category term="Hexo" scheme="https://lcl.shiqi217.com/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://lcl.shiqi217.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Vue2脚手架</title>
    <link href="https://lcl.shiqi217.com/2022/08/31/%E5%89%8D%E7%AB%AF/Vue%E7%9F%A5%E8%AF%86%E7%82%B9/Vue2%E8%84%9A%E6%89%8B%E6%9E%B6%E6%80%BB%E7%BB%93/"/>
    <id>https://lcl.shiqi217.com/2022/08/31/%E5%89%8D%E7%AB%AF/Vue%E7%9F%A5%E8%AF%86%E7%82%B9/Vue2%E8%84%9A%E6%89%8B%E6%9E%B6%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-31T09:59:15.643Z</published>
    <updated>2022-11-06T13:59:46.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构:"></a>脚手架文件结构:</h2><pre><code>|——node_modules |——public|    |—— favicon.ico: 页签图标 |    |—— index.html: 主页面 |     |—— src|        |—— assets:存放静态资源 |        |    |__ logo.png|        |—— component:存放组件 |        |    |__  HelloWorld.vue |        |—— App.vue:汇总所有组件 |        |—— main.js:入口文件|—— .gitignore: git版本管制忽略的配置|—— babel.config.js:babel的配置文件|—— package.json:用包配置文件|—— README.md:应用描述文件|—— package-lock.json:包版本控制文件</code></pre><h2 id="关于不同版本的Vue"><a href="#关于不同版本的Vue" class="headerlink" title="关于不同版本的Vue:"></a>关于不同版本的Vue:</h2><ul><li>vue.js与vue.runtime.xxx.js的区别:<br>(1).vue.js是完整版的Vue，包含:核心功能+模板解析器。<br>(2).vue.runtime.xxx.js是运行版的Vue，只包含:核心功能;没有模板解析器。</li><li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用<br>render数接收到的createElement函数去指定具体内容。</li></ul><h2 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h2><pre><code>&gt; 使用vue inspect &gt; output.js 可以查看到Vue脚手架的默认配置。&gt; 使用vue.config.js 可以对脚手架进行个性化定制，详情见: https://cli.vuejs.org/zh</code></pre><h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><pre><code>    1.被用来给元素或子组件注册引用信息 (id的替代者)    2.应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象VueComponent(vc)    3.使用方式:            打标识:&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt; 或 &lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;            获取: this.$refs.xxx</code></pre><h2 id="配置项props"><a href="#配置项props" class="headerlink" title="配置项props"></a>配置项props</h2><pre><code>    功能: 让组件接收外部传过来的数据    (1)传递数据:            &lt;Demo name=&quot;xxx&quot;/&gt;    (2)接收数据:            第一种方式(只接收):                     props:[&#39;name&#39;]            第二种方式(接收，并限制类型):                     props:&#123;                        name:String                        &#125;            第三种方式(限制类型、限制必要性、指定默认值):                     props:&#123;                            name:&#123;                              type:String，//类型                              required:true，//必要性                               default:&#39;老王&#39; //默认值                           &#125;                    &#125;    备注:props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，         若业务需求确实需要修改，那么请复制props的内容到data中一份，            然后去修改data中的数据。            props 比 data 先解析到页面，</code></pre><h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h2><pre><code>    功能:可以把多个组件共用的配置提取成一个混入对象    使用方式:            第一步定义混合，例如:                    &#123;                      data()&#123;....&#125;,                       methods:&#123;....&#125;,                      ....                    &#125;            第二步使用混入，例如:                    (1)全局混入:Vue.mixin(xxx)                    (2)局部混入:mixins:[&#39;xxx&#39;]</code></pre><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>​        功能:用于增强Vue<br>​        本质:包含instal1方法的一个对象，install的第一个参数是Vue，<br>​             第二个以后的参数是插件使用者传递的数据。<br>​        定义插件:I<br>​                对象.install = function(Vue,options){<br>​                // 1.添加全局过滤器<br>​                   Vue.filter(….)<br>​                // 2.添加全局指令<br>​                   Vue.directive(….)<br>​                // 3.配置全局混入(合)<br>​                   Vue.mixin(….)<br>​                // 4.添加实例方法<br>​                   Vue.prototype.$myMethod = function() {..}<br>​                   Vue.prototype $myProperty = xxxx<br>​                }<br>​                使用插件:Vue.use()</p><h2 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h2><pre><code>    作用：让样式在局部生效，防止冲突    写法：&lt;style scoped&gt;&lt;/style&gt;    在style 中 可更换其他样式 lang=&quot;css&quot;  不写lang 默认是css</code></pre><h2 id="总结TodoList案例"><a href="#总结TodoList案例" class="headerlink" title="总结TodoList案例"></a>总结TodoList案例</h2><pre><code>    1.组件化编码流程:I            (1)拆分静态组件:组件要按照功能点拆分，命名不要与html元素冲突。            (2)实现动态组件:考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用:                    1)一个组件在用:放在组件自身即可。                    2).一些组件在用:放在他们共同的父组件上(状态提升)。            (3)实现交互:从绑定事件开始。    2. props适用于:       (1)父组件==&gt;子组件通信       (2)子组件==&gt;父组件通信  (要求父先给子一个函数)    3.使用v-model时要切记:v-model绑定的值不能是props传过来的值，            因为props是不可以修改的!    4.props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，            但不推荐这样做。    组件化编码流程(通用)            1.实现静态组件:抽取组件，使用组件实现静态页面效果            2.展示动态数据:                    2.1.数据的类型、名称是什么?                    2.2.数据保存在哪个组件?            3交互-- 从绑定事件监听开始</code></pre><h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><p>​        1.存储内容大小一般支持5MB左右(不同浏览器可能还不一样)<br>​        2.浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。<br>​        3.相关API:<br>​                1.xxxxxStorage.setItem(‘key’,’value’);<br>​                     该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值<br>​                2.xxxxxStorage.getItem(‘person’);<br>​                     该方法接受一个键名作为参数，返回键名对应的值。<br>​                3.xxxxxStorage.removeItem(‘key’);<br>​                     该方法接受一个键名作为参数，并把该键名从存储中删除。</p><pre><code>            4. xxxxxStorage.clear()                 该方法会清空存储中的所有数据。            4.备注:                  1.SessionStorage存储的内容会随着浏览器窗口关闭而消失。                  2.LocalStorage存储的内容，需要手动清除才会消失                  3.xxxxxStorage.getItem(xxx)如果xxx对应的value获取不到，那么getitem的返回值是null                  4.JSON.parse(null)的结果依然是null</code></pre><h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><p>1.一种组件间通信的方式，适用于:<strong>子组件==&gt;父组件</strong></p><p>2.使用场景:A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件(<em><strong>事件的回调在A中</strong></em>)。</p><p>3.绑定自定义事件:<br>        1.第一种方式，在父组件中: <code>&lt;Demo @dakai=&quot;test&quot;/&gt;</code> 或 <code>&lt;Demo v-on:dakai=&quot;test&quot;/&gt;</code><br>        2第二种方式，在父组件中:<br>                <Demo ref="demo"/><br>                …..<br>                mounted(){<br>                this.$refs.xxx.$on(‘’,this.test)<br>                }</p><pre><code>    3.若想让自定义事件只能触发一次，可以使用 once 修饰符，或 $once 方法。</code></pre><p>4.触发自定义事件: <code>this.$emit(&#39;dakai&#39;,数据)</code></p><p>5.解绑自定义事件 <code>this.$off(&#39;dakai&#39;)</code></p><p>6.组件上也可以绑定原生DOM事件，需要使用native修饰符。</p><p>7.注意:通过this.$refs.xxx.$on(dakai，回调)绑定自定义事件时，<br>   回调<strong>要么配置在methods中，要么用箭头函数</strong>，否则this指向会出问题!</p><h2 id="全局事件总线-GlobalEventBus"><a href="#全局事件总线-GlobalEventBus" class="headerlink" title="全局事件总线(GlobalEventBus)"></a>全局事件总线(GlobalEventBus)</h2><p>   1一种组件间通信的方式，适用于任意组件间通信。</p><p>   2.安装全局事件总线:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">          .....</span><br><span class="line">          <span class="title function_">beforeCreate</span>(<span class="params"></span>)&#123;</span><br><span class="line">              <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span>=<span class="variable language_">this</span>  <span class="comment">//安装全局事件总线，$bus就是当前应用的vm</span></span><br><span class="line">          &#125;，</span><br><span class="line">          .....</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>   3.使用事件总线:</p><p>​        1接收数据:A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<strong>回调留在A组件自身</strong></p><pre><code>    methods()&#123;         demo(data)(.....)    &#125;    ....    mounted()&#123;        this.$bus.$on(&#39;xxxx&#39;,this.demo)    &#125;    2.提供数据: `this.$bus.$emit(&#39;xxxx&#39; , 数据)`</code></pre><p>   4.最好在beforeDestroy钩子中，用$off去解绑<strong>当前组件所用到的</strong>事件。</p><h2 id="消息订阅与发布-pubsub"><a href="#消息订阅与发布-pubsub" class="headerlink" title="消息订阅与发布(pubsub)"></a>消息订阅与发布(pubsub)</h2><p>1一种组件间通信的方式，适用于<strong>任意组件间通信</strong>。</p><p>2.使用步骤:<br>    1.安装 <code>pubsub: npm i pubsub-js</code><br>    2.引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p><p>3.接收数据:A组件想接收数据，则在A组件中订阅消息，订阅的<strong>回调留在A组件自身</strong>。</p><pre><code>    methods()&#123;        demo(data)&#123;......&#125;        &#125;    ......        mounted() &#123;    this.pid = pubsub.subscribe(&#39;xxx&#39;,this.demo)//订阅消息    &#125;</code></pre><p>4.提供数据: <code>pubsub.publish(xxx&#39;,数据)</code><br>5.最好在beforeDestrov钩子中，用<code>PubSubunsubscribe(pid)</code>去<span style="color:red">取消订阅</span></p><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick*"></a>nextTick*</h2><p>1.语法: <code>this.$nextTick(回调函数)</code> </p><p>2.作用: 在下一次 DOM 更新结束后执行其指定的回调。</p><p>3.什么时候用: 当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</p><h2 id="Vue封装的过度与动画"><a href="#Vue封装的过度与动画" class="headerlink" title="Vue封装的过度与动画"></a>Vue封装的过度与动画</h2><p>1.作用:在插入、更新或移除DOM元素时，在合适的时候给元素添加样式类名。</p><p>2.图示:</p><p><img src="C:\Users\86173\Desktop\vue_test\img\动画.png" style="zoom:67%;" /></p><p>3.写法:<br>            1.准备好样式:<br>                    <strong>· </strong>元素进入的样式:</p><p>​                         1 v-enter:进入的起点</p><p>​                         2.v-enter-active:进入过程中</p><p>​                         3v-enter-to:进入的终点</p><p>​              <strong>·</strong> 元素离开的样式:</p><p>​                        1.v-leave:离开的起点</p><p>​                        2.v-leave-active:离开过程中</p><p>​                        3v-leave-to:离开的终点</p><p>​                总结：进入的起点 = 离开的终点    进入的终点 = 离开的起点</p><p>​                补充： 在行内中添加 修饰词：引用一些动画库可以实现一些别人定义好的动画</p><p>​                        <code>enter-active-class=&quot;进入过程中动画&quot;</code></p><p>​                        <code>leave-active-class=&quot;离开过程中动画&quot;</code></p><p>​        2.使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性:    </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;transition name=<span class="string">&quot;hello&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>你好啊!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure><p>​        3.备注:若有多个元素需要过度，则需要使用: <code>&lt;transition-group&gt;</code>，</p><p>​        且每个元素都要指定<code>key</code>值。</p><p>​    4.可以通过调用动画库实现动画效果：</p><p>​        首先第一步安装：<code>npm install animate.css</code></p><p>​        第二步：引用animate库</p><p>​                在script中 引用：<code>import &#39;animate.css&#39;</code></p><p>​        第三步：打开此网站： <a href="https://animate.style/">https://animate.style/</a>        </p><p>​                可以看到一些动态的动画</p><p>​        第四步：只需要在 <transition name="animate__animated animate__bounce">    </p><p>​                    name中引入    <code>animate__animated animate__bounce</code></p><p>​        第五步：在<code>enter-active-class</code>写入进入过程中的动画名</p><p>​                            例如：<code>enter-active-class=“animate__bounceInRight”</code></p><p>​                        在 <code>leave-active-class</code>写入离开过程中的动画名</p><p>​                            例如：<code>leave-active-class=&quot;animate__bounceOutDown&quot;</code></p><p>​        </p><h2 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a>vue脚手架配置代理</h2><h6 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h6><p>​         在vueconfigjs中添加如下配置:</p><pre><code>    devServer:&#123;    proxy:&quot;http://localhost:5000    &#125;</code></pre><p>说明:</p><p>​        1.优点:   配置简单，请求资源时直接发给前端(8080)即可。</p><p>​        2.缺点:   不能配置多个代理，不能灵活的控制请求是否走代理</p><p>​        3.工作方式:   若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器(优先匹配前端资源)</p><h6 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h6><p>​        编写vueconfigjs配置具体代理规则:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">devServer</span>: &#123; </span><br><span class="line">  <span class="attr">proxy</span>:&#123;</span><br><span class="line"><span class="string">&#x27;/api1&#x27;</span>:&#123; <span class="comment">//匹配所有以/api1&#x27;开头的请求路径</span></span><br><span class="line"><span class="attr">target</span>:<span class="string">&#x27;http://localhost:5000&#x27;</span>,<span class="comment">// 代理目标的基础路径 </span></span><br><span class="line"><span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">pathRewrite</span>:&#123;<span class="string">&#x27;^/api1&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">&#125;，</span><br><span class="line"><span class="string">&#x27;/api2&#x27;</span>:&#123;<span class="comment">// 匹配所有以&#x27;/api2&quot;开头的请求路径</span></span><br><span class="line"><span class="attr">target</span>:<span class="string">&#x27;http://localhost:&#x27;</span><span class="number">5001</span><span class="string">&#x27;,/代理目标的基础路径 </span></span><br><span class="line"><span class="string">changeOrigin: true,</span></span><br><span class="line"><span class="string">pathRewrite:&#123;&#x27;</span>^/api2<span class="string">&#x27;:&#x27;</span><span class="string">&#x27;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">/*</span></span><br><span class="line"><span class="string">changeOrigin设置为true时，服务器收到的请求头中的host为:localhost:5000 (撒谎)</span></span><br><span class="line"><span class="string">changeOrigin设置为false时，服务器收到的请求头中的host为:localhost:8080  (不撒谎)</span></span><br><span class="line"><span class="string">changeOrigin默认值为true</span></span><br><span class="line"><span class="string">*/</span></span><br></pre></td></tr></table></figure><p>说明：</p><pre><code>1. 优点： 可以配置多个代理，且可以灵活的控制请求是否走代理1. 缺点： 配置略微繁琐，请求资源时必须加上前缀</code></pre><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><p>​        1.作用:让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，</p><p>​            适用于<strong>父组件===&gt;子组件。</strong><br>​        2.分类:默认插槽、具名插槽、作用域插槽<br>​        3.使用方式:<br>​                1.默认插槽:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">父组件中:<span class="string">`</span></span><br><span class="line"><span class="string">&lt;Category&gt;`</span></span><br><span class="line">&lt;div&gt;html结构<span class="number">1</span>&lt;/div&gt;</span><br><span class="line">&lt;/<span class="title class_">Category</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">`子组件中:`</span></span><br><span class="line"><span class="string">`&lt;template&gt;`</span></span><br><span class="line"><span class="string">`&lt;div&gt;`</span></span><br><span class="line"><span class="string">`&lt;!--定义插槽 --&gt;`</span></span><br><span class="line"><span class="string">`&lt;slot&gt;插槽默认内容...&lt;/slot&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;`</span></span><br><span class="line"><span class="string">`&lt;/template&gt;`</span></span><br></pre></td></tr></table></figure><p>​            2.具名插槽:</p><p>​    </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">父组件中:</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Category</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>html结构1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>html结构2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">子组件中:</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!--定义插槽 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;center&quot;</span>&gt;</span>插槽默认内容...<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>插槽默认内容...<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>3.作用域插槽:</strong><br>        1.理解:<strong>数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定</strong>。</p><p>​                (games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定)<br>​        2.具体编码:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">父组件中:</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Category</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">scope</span>=<span class="string">&quot;scopeData&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="comment">&lt;!--生成的是ul列表 --&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;g in scopeData.games&quot;</span><span class="attr">:key</span>=<span class="string">&quot;g&quot;</span>&gt;</span>&#123;&#123;g&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span></span><br><span class="line">        </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Category</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;scopeData&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="comment">&lt;!--生成的是h4标题 --&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h4</span> <span class="attr">v-for</span>=<span class="string">&quot;g in scopeData.games&quot;</span><span class="attr">:key</span>=<span class="string">&quot;g&quot;</span>&gt;</span>&#123;&#123;g&#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span></span><br><span class="line">        </span><br><span class="line">子组件中:</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:games</span>=<span class="string">&quot;games&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">name</span>:<span class="string">&#x27;Category&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">//数据在子组件自身 </span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">props</span>:[<span class="string">&#x27;title&#x27;</span>], </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="attr">games</span>:[<span class="string">&#x27;和平精英&#x27;</span>,<span class="string">&#x27;穿越火线&#x27;</span>,<span class="string">&#x27;王者荣耀&#x27;</span>,<span class="string">&#x27;英雄联盟&#x27;</span>]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;，</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>vuex是什么</p><p>​        1.概念:专门在Vue中实现集中式状态 (数据) 管理的一个Vue插件，对vue应用中</p><p>​                多个组件的共享状态进行集中式的管理(读/写)，也是一种组件间通信的方式，且适用于任意组件间通信。</p><p>​        2. Github地址:  <a href="https://githubcom/vuejs/vuex">https://githubcom/vuejs/vuex</a></p><h4 id="1、什么时候使用Vuex"><a href="#1、什么时候使用Vuex" class="headerlink" title="1、什么时候使用Vuex"></a>1、<strong>什么时候使用Vuex</strong></h4><p>​        1.多个组件依赖于同一状态，<br>​        2.来自不同组件的行为需要变更同一状态</p><p><strong>何时使用?</strong></p><p>​            多个组件需要共享数据时</p><h4 id="2、搭建vuex环境"><a href="#2、搭建vuex环境" class="headerlink" title="2、搭建vuex环境"></a><strong>2、搭建vuex环境</strong></h4><p>​        1.创建文件:<code>src/store/index.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span><span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span><span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//应用Vuex插件 </span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions对象一响应组件中用户的动作 </span></span><br><span class="line"><span class="keyword">const</span> actions=&#123;&#125;</span><br><span class="line">/准备mutations对象一修改state中的数据 </span><br><span class="line"><span class="keyword">const</span> mutations=&#123;&#125;</span><br><span class="line"><span class="comment">//准备state对象一-保存具体的数据 </span></span><br><span class="line"><span class="keyword">const</span> state =&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">actions, </span><br><span class="line">mutations, </span><br><span class="line">state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2.在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span><span class="string">&#x27;./store&#x27;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vm </span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line"><span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>), </span><br><span class="line">store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="C:\Users\86173\AppData\Roaming\Typora\typora-user-images\image-20220822230256023.png" alt="image-20220822230256023" style="zoom:50%;" /></p><h4 id="3、基本使用"><a href="#3、基本使用" class="headerlink" title="3、基本使用"></a>3、基本使用</h4><p>​    1.初始化数据、配置 <code>actions</code> 、配置 <code>mutations</code> ， 操作文件 <code>store.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//引用Vuex </span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions =&#123;</span><br><span class="line"><span class="comment">//响应组件中加的动作 </span></span><br><span class="line"><span class="title function_">jia</span>(<span class="params">context,value</span>)&#123;</span><br><span class="line"><span class="comment">//console.log(actions中的jia被调用了&#x27;,miniStore,value) </span></span><br><span class="line">context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>,value)</span><br><span class="line">&#125;，</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations=&#123;</span><br><span class="line"><span class="comment">//执行加</span></span><br><span class="line"><span class="title function_">JIA</span>(<span class="params">state,value</span>)&#123;</span><br><span class="line"><span class="comment">//console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value) </span></span><br><span class="line">state.<span class="property">sum</span> += value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化数据</span></span><br><span class="line"><span class="keyword">const</span> state=&#123;</span><br><span class="line"><span class="attr">sum</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">actions,</span><br><span class="line">mutations,</span><br><span class="line">state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2.组件中读取vuex中的数据: <code>$store.state.sum</code></p><p>3.组件中修改vuex中的数据: <code>$store.dispatch(&#39;action中的方法名&#39;，数据)</code></p><p>​    或    <code>$store.commit(&#39;mutations中的方法名&#39;，数据)</code></p><p><strong>备注:</strong></p><p>​    若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写 <code>dispatch</code>，直接编写 <code>commit</code></p><h4 id="4、getters的使用"><a href="#4、getters的使用" class="headerlink" title="4、getters的使用"></a>4、getters的使用</h4><ol><li><p>概念:当state中的数据需要经过加工后再使用时，可以使用getters加工。</p><p>​    如果逻辑复杂，并且逻辑要复用推荐 <code>getters</code></p><ol><li>在<code>store.js</code>中追加<code>getters</code>配置</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line"><span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> state.<span class="property">sum</span>*<span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title function_">store</span>(&#123;</span><br><span class="line">......</span><br><span class="line">getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.组件中读取数据：<code>$store.getters.bigSum</code></p><h4 id="5、四个map方法的使用"><a href="#5、四个map方法的使用" class="headerlink" title="5、四个map方法的使用"></a>5、四个map方法的使用</h4><p>​        1.<strong>mapState方法</strong>:用于帮助我们映射<code>state</code>中的数据为计算属性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">//借助mapState生成计算属性:sum、school、subject(对象写法)</span><br><span class="line">...mapState(&#123;sum:&#x27;sum&#x27;,school:&#x27;school&#x27;,subject:&#x27;subject&#x27;&#125;).</span><br><span class="line"></span><br><span class="line">//借助mapState生成计算属性:sum、school、subject(数组写法)</span><br><span class="line">...mapState([&#x27;sum&#x27;,&#x27;school&#x27;, &#x27;subject&#x27;])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>​        2. <strong>mapGetters方法</strong>:用于帮助我们映射<code>getters</code>中的数据为计算属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line"><span class="comment">//借助mapGetters生成计算属性:bigSum(对象写法)</span></span><br><span class="line">...<span class="title function_">mapGetters</span>(&#123;<span class="attr">bigSum</span>:<span class="string">&#x27;bigSum&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line"><span class="comment">//借助mapGetters生成计算属性:bigSum(数组写法)</span></span><br><span class="line">...<span class="title function_">mapGetters</span>([<span class="string">&#x27;bigSum&#x27;</span>])</span><br><span class="line">&#125;，</span><br></pre></td></tr></table></figure><p>​        3.<strong>mapActions方法</strong>:用于帮助我们生成与<code>actions</code>对话的方法，即: 包含<code>$store.dispatch(xxx)</code>的函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line"><span class="comment">//靠mapActions生成:incrementOdd、incrementWait(对象形式)</span></span><br><span class="line">...<span class="title function_">mapActions</span>(&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//靠mapActions生成:incrementOdd incrementWait(数组形式)</span></span><br><span class="line">...<span class="title function_">mapActions</span>([<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="string">&#x27;jiaWait&#x27;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>4.方法</strong>: 用于帮助我们生成与<code>mutations</code>对话的方法，即:包含<code>$store.commit(xxx)</code>的函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line"><span class="comment">//靠mapActions生成:increment、decrement(对象形式)</span></span><br><span class="line">...<span class="title function_">mapMutations</span>(&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line"><span class="comment">//靠mapMutations生成:JIA、JIAN(对象形式)</span></span><br><span class="line">...<span class="title function_">mapMutations</span>([<span class="string">&#x27;JIA&#x27;</span>,<span class="string">&#x27;JIAN&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>备注</strong>: <code>mapActions</code>与<code>mapMutations</code>使用时，若需要传递参数, 需要在模板中绑定事件时传递好参数，否则参数是事件对象。</p><h4 id="7-模块化-命名空间"><a href="#7-模块化-命名空间" class="headerlink" title="7.模块化+命名空间"></a>7.模块化+命名空间</h4><p>​        1.目的:让代码更好维护，让多种数据分类更加明确。</p><p>​        2.修改<code>store.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> countAbout=&#123;</span><br><span class="line"><span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间 </span></span><br><span class="line"><span class="attr">state</span>:&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;，</span><br><span class="line"><span class="attr">mutations</span>:&#123; ·. &#125;, </span><br><span class="line"><span class="attr">actions</span>:&#123;·.&#125;, </span><br><span class="line"><span class="attr">getters</span>:&#123;</span><br><span class="line"><span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> state.<span class="property">sum</span>*<span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personAbout = &#123;</span><br><span class="line"><span class="attr">namespaced</span>:<span class="literal">true</span>，<span class="comment">//开启命名空间 </span></span><br><span class="line"><span class="attr">state</span>:&#123; ... &#125;,</span><br><span class="line"><span class="attr">mutations</span>:&#123; ... &#125;, </span><br><span class="line"><span class="attr">actions</span>:&#123; ... &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store =<span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123; </span><br><span class="line"><span class="attr">modules</span>:&#123; </span><br><span class="line">countAbout, </span><br><span class="line">personAbout</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.开启命名空间后，组件中读取<code>state</code>数据:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一: 自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">personAbout</span>.<span class="property">list</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二:借助mapState读取:</span></span><br><span class="line">...<span class="title function_">mapState</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br></pre></td></tr></table></figure><p>4.开启命名空间后，组件中读取<code>getters</code>数据:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一:自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&#x27;personAbout/firstPersonName’]</span></span><br><span class="line"><span class="string">//方式二:借助mapGetters读取:</span></span><br><span class="line"><span class="string">...mapGetters(&#x27;</span>countAbout<span class="string">&#x27;,[&#x27;</span>bigSum<span class="string">&#x27;])</span></span><br></pre></td></tr></table></figure><p>5.开启命名空间后，组件中调用<code>dispatch</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一:自己直接dispatch</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;personAbout/addPersonWang&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二:借助mapActions:</span></span><br><span class="line">...<span class="title function_">mapActions</span>(<span class="string">&#x27;countAbout’,&#123;incrementOdd:&#x27;</span>jiaOdd<span class="string">&#x27;,incrementWait:&#x27;</span>jiaWait<span class="string">&#x27;&#125;)</span></span><br></pre></td></tr></table></figure><p>6.开启命名空间后，组件中调用<code>commit</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一:自己直接commit</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;personAbout/ADD PERSON&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二:借助mapMutations:</span></span><br><span class="line">..<span class="title function_">mapMutations</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br></pre></td></tr></table></figure><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>​    1.理解:  一个路由Groute)就是一组映射关系(key-value)，多个路由需要路由器(router)进行管理。<br>​    2.前端路由:key是路径，value是组件。</p><h4 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h4><p>​        1.安装vue-router 打开终端输入 <code>npm i vue-router</code></p><p>​            <strong>注意</strong>：如果现在用的是vue2 那么安装 <code>npm i vue-router@3</code> vue-router三版本</p><p>​                        如果用的是vue3 就去掉后缀的 <strong>@3</strong>        2.应用插件:Vue.use(VueRouter)<br>​        3.编写router配置项:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入VueRouter</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//引入Luyou组件</span></span><br><span class="line"><span class="string">import About from&#x27;</span>../components/<span class="title class_">About</span> </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span><span class="string">&#x27;../components/Home</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//创建router实例对象，去管理一组一组的路由规则 </span></span><br><span class="line"><span class="string">const router=new VueRouter(&#123;</span></span><br><span class="line"><span class="string">routes:[</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">  path:&#x27;</span>/about<span class="string">&#x27;, </span></span><br><span class="line"><span class="string">  component:About</span></span><br><span class="line"><span class="string">  &#125;，</span></span><br><span class="line"><span class="string">  &#123;</span></span><br><span class="line"><span class="string">  path:&#x27;</span>/home<span class="string">&#x27;, </span></span><br><span class="line"><span class="string">  component:Home</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">//暴露router</span></span><br><span class="line"><span class="string">export default router</span></span><br></pre></td></tr></table></figure><p><strong>4.实现切换(active-class可配置高亮样式)</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;router-link active-<span class="keyword">class</span>=<span class="string">&quot;active&quot;</span> to = <span class="string">&quot;/about&quot;</span>&gt;<span class="title class_">About</span>&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>5.指定展示位置</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><h4 id="2-理解-vue-router"><a href="#2-理解-vue-router" class="headerlink" title="2. 理解 vue-router"></a>2. 理解 vue-router</h4><p>​        <strong>vue-router的理解</strong></p><p>​                vue的一个插件库，专门用来实现SPA应用</p><p>​        <strong>对SPA应用的理解</strong></p><p>​                1.单页Web应用(singlepagewebapplicationSPA)。</p><p>​                2.整个应用只有<strong>一个完整的页面</strong>。</p><p>​                3.点击页面中的导航链接<strong>不会刷新</strong>页面，只会做页面的<strong>局部更新</strong>。</p><p>​                4.数据需要通过ajax请求获取。</p><p><strong>路由的理解</strong></p><p>​    1.什么是路由?<br>​            一个路由就是一组映射关系    (key-value)</p><p>​            多个路由，需要经过路由器的管理</p><ol><li>key为路径value可能是function或componente</li><li>路由分类</li><li>后端路由:</li></ol><p>​                    1)理解:value是function，用于处理客户端提交的请求。</p><p>​                    2)工作过程:服务器接收到一个请求时，根据<strong>请求路径**</strong>找到匹配的函数来处**</p><p>理请求，返回响应数据。</p><p>​            2. 前端路由:</p><p>​                    1)理解   value 是 component，用于展示页面内容。</p><p>​                    2)工作过程:  当浏览器的路径改变时，对应的组件就会显示</p><h4 id="3-几个注意点"><a href="#3-几个注意点" class="headerlink" title="3.几个注意点:"></a>3.几个注意点:</h4><p>​    1.路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</p><p>​    2.通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</p><p>​    3.每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</p><p>​    4.整个应用只有一个<code>router</code>，可以通过组件的<code>$router</code>属性获取到。</p><h4 id="4-路由的query参数"><a href="#4-路由的query参数" class="headerlink" title="4.路由的query参数"></a>4.路由的query参数</h4><p>1.传递参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;/home/message/detail?id=666&amp;title=你好&quot;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  &lt;!--跳转并携带query参数，to的对象写法 --&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        path:&#x27;/home/message/detail&#x27;, </span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        query:&#123;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">          id:666,</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">          title:&#x27;你好&#x27;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">        &#125;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">    &#125;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.接收参数:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$route.<span class="property">query</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">query</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure><h4 id="5-命名路由"><a href="#5-命名路由" class="headerlink" title="5.命名路由"></a>5.命名路由</h4><p>​    1作用:可以简化路由的跳转。</p><p>​    2.如何使用</p><p>​        1.给路由命名:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/demo&#x27;</span>, </span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Demo</span>, </span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;test&#x27;</span>, </span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Test</span>, </span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;hello&#x27;</span>,<span class="comment">//给路由命名 </span></span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;welcome&#x27;</span>, </span><br><span class="line"><span class="attr">component</span>:<span class="title class_">Hello</span>,</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.简化跳转：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--简化前，需要写完整的路径--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/demo/test/welcome&quot;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!--简化后，直接通过名字跳转 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!--简化写法配合传递参数 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">name:hello&#x27;, </span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">query:&#123;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">id:666,</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">title:&quot;</span><span class="attr">你好</span>&quot;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&#125;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="6-路由的params参数"><a href="#6-路由的params参数" class="headerlink" title="6.路由的params参数"></a><strong>6.路由的params参数</strong></h4><p>​        1.配置路由，声明接收params参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:/home<span class="string">&#x27;, </span></span><br><span class="line"><span class="string">component:Home,</span></span><br><span class="line"><span class="string">children:[</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">path: &#x27;</span>news<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">component:News,</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">component:Message, </span></span><br><span class="line"><span class="string">children:[</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">name:&#x27;</span>xiangqing<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">path:&#x27;</span>detail/:id/:title<span class="string">&#x27;，//使用占位符声明接收params参数 </span></span><br><span class="line"><span class="string">component:Detail</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>2.传递参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--跳转并携带params参数，to的字符串写法 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;/home/message/detail/666/你好&quot;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!--跳转并携带params参数，to的对象写法 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">name: &#x27;xiangqing&#x27;, </span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">params:&#123;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">id:666,</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">title:&#x27;你好</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">&#125;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意:"></a>特别注意:</h5><p>​    路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置!</p><p>3.接收参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$route.<span class="property">params</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">params</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure><p>7.路由的props配置</p><p>​    作用：让路由组件更方便的收到参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>, </span><br><span class="line"><span class="attr">path</span>:detail/:id<span class="string">&#x27;, </span></span><br><span class="line"><span class="string">component:Detail,</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//第一种写法:props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span></span><br><span class="line"><span class="string">// props:&#123;a:900&#125;</span></span><br><span class="line"><span class="string">//第二种写法:props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span></span><br><span class="line"><span class="string">// props:true</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//第三种写法:props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件 props(route)&#123;</span></span><br><span class="line"><span class="string">return &#123;</span></span><br><span class="line"><span class="string">id:route.query.id,</span></span><br><span class="line"><span class="string">title:route.query.title</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="8-lt-router-link-gt-的replace属性"><a href="#8-lt-router-link-gt-的replace属性" class="headerlink" title="8.&lt;router-link&gt;的replace属性"></a>8.<code>&lt;router-link&gt;</code>的replace属性</h4><p>​        1.作用:控制路由跳转时操作浏览器历史记录的模式</p><p>​        2.浏览器的历史记录有两种写入方式:分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></p><p>​        3.如何开启<code>replace</code>模式:<code>&lt;router-link replace.......&gt;News&lt;/router-link&gt;</code></p><h4 id="9-编程式路由导航"><a href="#9-编程式路由导航" class="headerlink" title="9.编程式路由导航"></a>9.编程式路由导航</h4><p>1.作用：不借助<code>&lt;router-link&gt;</code>实现路由跳转，让路由跳转更加灵活</p><p>2.具体编码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//$router的两个API </span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">params</span>:&#123;</span><br><span class="line"><span class="attr">id</span>:xxx, </span><br><span class="line"><span class="attr">title</span>:xxx</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">params</span>:&#123;</span><br><span class="line"><span class="attr">id</span>:xxx, </span><br><span class="line"><span class="attr">title</span>:xxx</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>() <span class="comment">//前进</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>() <span class="comment">//后退</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>(步数)<span class="comment">//可前进也可后退 正数前进，负数后退</span></span><br></pre></td></tr></table></figure><h4 id="10-缓存路由组件"><a href="#10-缓存路由组件" class="headerlink" title="10.缓存路由组件"></a>10.缓存路由组件</h4><p>​        1.作用:让不展示的路由组件保持挂载，不被销毁。</p><p>​        2.具体编码:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;News&quot;</span>&gt;</span>//include 缓存的是组件名</span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="11、两个新的生命周期钩子"><a href="#11、两个新的生命周期钩子" class="headerlink" title="11、两个新的生命周期钩子"></a>11、两个新的生命周期钩子</h4><p>​        1.作用:  路由组件所独有的两个钩子用于捕获路由组件的激活状态。</p><p>​        2.具体名字:<br>​                    1.<code>activated</code> 路由组件被激活时触发。</p><p>​                    2. <code>deactivated</code> 路由组件失活时触发。（取消激活时触发）</p><h4 id="12、路由守卫"><a href="#12、路由守卫" class="headerlink" title="12、路由守卫"></a>12、路由守卫</h4><p>​        1.作用:对路由进行权限控制</p><p>​        2.分类:全局守卫、独享守卫、组件内守卫</p><p>​        3.<strong>全局守卫</strong>:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫:初始化时执行、每次路由切换前执行 </span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(beforeEach<span class="string">&#x27;,to,from)</span></span><br><span class="line"><span class="string">if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制</span></span><br><span class="line"><span class="string">if(localStorage.getItem(schoo1&#x27;</span>)==<span class="string">&#x27;dakai&#x27;</span>)&#123;<span class="comment">//权限控制的具体规则</span></span><br><span class="line"><span class="title function_">next</span>()<span class="comment">//放行</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看)</span></span><br><span class="line"><span class="string">// next(&#123;name:&#x27;</span>dakai<span class="string">&#x27;&#125;)</span></span><br><span class="line"><span class="string">&#125;else&#123;</span></span><br><span class="line"><span class="string">next() //放行</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//全局后置守卫，初始化时执行、每次路由切换后执行 router.afterEach((to,from)=&gt;&#123;</span></span><br><span class="line"><span class="string">console.log(&#x27;</span>afterEach<span class="string">&#x27;,to,from) </span></span><br><span class="line"><span class="string">if(to.meta.title)&#123;</span></span><br><span class="line"><span class="string">document.title=to.meta.title  //修改网页的title</span></span><br><span class="line"><span class="string">&#125;else&#123;</span></span><br><span class="line"><span class="string">document.title = &#x27;</span>vue_test<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><p>4.<strong>独享守卫</strong>：</p><p>​    </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">beforeEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEnter&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line"><span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123;<span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line"><span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5<strong>.组件内守卫</strong>:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入守卫:通过路由规则，进入该组件时被调用</span></span><br><span class="line"> <span class="title function_">beforeRouteEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line"> </span><br><span class="line"> &#125;,</span><br><span class="line"><span class="comment">//离开守卫:通过路由规则，离开该组件时被调用 </span></span><br><span class="line"><span class="title function_">beforeRouteLeave</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;脚手架文件结构&quot;&gt;&lt;a href=&quot;#脚手架文件结构&quot; class=&quot;headerlink&quot; title=&quot;脚手架文件结构:&quot;&gt;&lt;/a&gt;脚手架文件结构:&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;|——node_modules 
|——public
|    |—— favi</summary>
      
    
    
    
    <category term="前端" scheme="https://lcl.shiqi217.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Vue" scheme="https://lcl.shiqi217.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue2知识点</title>
    <link href="https://lcl.shiqi217.com/2022/08/29/%E5%89%8D%E7%AB%AF/Vue%E7%9F%A5%E8%AF%86%E7%82%B9/Vue2%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://lcl.shiqi217.com/2022/08/29/%E5%89%8D%E7%AB%AF/Vue%E7%9F%A5%E8%AF%86%E7%82%B9/Vue2%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-28T20:02:17.000Z</published>
    <updated>2022-10-05T08:35:47.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue总结"><a href="#Vue总结" class="headerlink" title="Vue总结"></a>Vue总结</h1><h2 id="初识Vue"><a href="#初识Vue" class="headerlink" title="初识Vue:"></a>初识Vue:</h2><pre><code>    1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象;    2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法:    3.root容器里的代码被称为【Vue模板】:    4.Vue实例和容器是一一对应的;    5.真实开发中只有一个Vue实例，并且会配合着组件一起使用;    6.&#123;&#123;xxx&#125;&#125;中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性;    7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新;    注意区分:js表达式和js代码(语句)    1.表达式:一个表达式会产生一个值，可以放在任何一个需要值的地方:    (1).a(2). a+b    (3).demo(1)    (4). x=== y ? &#39;a&#39; : &#39;b&#39;    2.js代码(语句)    (1). if()&#123;&#125;(2). for()&#123;&#125;</code></pre><h2 id="Vue模板有两大类"><a href="#Vue模板有两大类" class="headerlink" title="Vue模板有两大类"></a>Vue模板有两大类</h2><pre><code>        1.插值语法:            功能：用于解析标签体内容            写法： &#123;&#123;xxx&#125;&#125; xxx是js表达式，而且可以直接读取到data中的所有属性        2.指令语法：            功能：用于解析标签 (包括，标签属性，标签体内容，绑定事件....)            举例：  v-bind:href=&quot;xxx&quot;  ====&gt; :href=&quot;xxx&quot; xxx同样是js表达式                    且可以直接读取到data中的所有属性</code></pre><h2 id="Vue有两种绑定方式，"><a href="#Vue有两种绑定方式，" class="headerlink" title="Vue有两种绑定方式，"></a>Vue有两种绑定方式，</h2><pre><code>        1.单向绑定(v-bind: )数据只能从data流向页面        2.双向绑定(v-model:) 数据不仅能从data流向页面。还可以从页面流向data        备注：            1.双向绑定，一般应用在表单类元素上，(如: input select...)            2.v-model:value 可以简写为v-model. 因为v-model默认收集的就是value值</code></pre><h2 id="data-与-el的2种写法"><a href="#data-与-el的2种写法" class="headerlink" title="data 与 el的2种写法"></a>data 与 el的2种写法</h2><pre><code>    1.el有2种写法    (1).new Vue 的时候配置el属性。    (2),先创建Vue实例,随后再通过vm.$mount(&#39;#root&#39;)指定el的值。    2.data有2种写法    (1).对象式    (2).函数式    如何选择:目前哪种写法都可以,以后学习到组件时,data必须使用函数式,否则会报错。    3,一个重要的原则:    由Vue管理的函数,一定不要写箭头函数,一旦写了箭头函数,this就不再是Vue实例了。而是window</code></pre><h2 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.M:模型(Model):data中的数据</span><br><span class="line">            2.V:视图(View):模板代码</span><br><span class="line">            3.VM:视图模型(ViewModel):Vue实例观察发现:</span><br><span class="line">                1.data中所有的属性，最后都出现在了vm身上。</span><br><span class="line">                2.vm身上所有的属性及Vue原型上所有属性，在Vue模板中都可以直接使用。</span><br></pre></td></tr></table></figure><h2 id="回顾Object-defineproperty方法"><a href="#回顾Object-defineproperty方法" class="headerlink" title="回顾Object.defineproperty方法"></a>回顾Object.defineproperty方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.defineproperty 的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性</span><br><span class="line">        Object.defineproperty方法需要传递3个参数</span><br><span class="line">        Object.defineproperty（obj, prop, desc  ）</span><br><span class="line">        参数1：obj     需要定义属性的当前对象</span><br><span class="line">        参数2：prop    当前需要定义的属性名</span><br><span class="line">        参数3：desc    描述符 一般是一个对象</span><br></pre></td></tr></table></figure><h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2><pre><code>    数据代理： 通过一个对象代理对另一个对象中属性的操作(读/写)1.Vue中的数据代理:    通过vm对象来代理data对象中属性的操作(读/写)2.Vue中数据代理的好处:    更加方便的操作data中的数据3.基本原理:    通过Object.defineProperty()把data对象中所有属性添加到vm上。    为每一个添加到vm上的属性，都指定一个getter/setter。    在getter/setter内部去操作(读/写)data中对应的属性。</code></pre><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><pre><code>v-on: 用来给目标元素绑定事件的，事件的类型由参数决定使用 methods 属性给 Vue 定义方法    只要methods里面关联的代码一改变，methods就会加载一次重新解析模板事件的基本使用:1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名;2.事件的回调需要配置在methods对象中，最终会在vm上:3.methods中配置的数，不要用箭头函数!否则this就不是vm了;4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象;5.@click=&quot;demo&quot; 和 @click=&quot;demo($event)&quot;效果一致，但后者可以传参;</code></pre><h3 id="Vue中的事件修饰符"><a href="#Vue中的事件修饰符" class="headerlink" title="Vue中的事件修饰符:"></a>Vue中的事件修饰符:</h3><pre><code>        1.prevent:阻止默认事件(常用);        2.stop:阻止事件冒泡(常用);        3.once:事件只触发一次(常用);        4.capture:使用事件的捕获模式;        5.self:只有event.target是当前操作的元素时才触发事件;        6.passive:事件的默认行为立即执行，无需等待事件回调执行完毕，</code></pre><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><pre><code>    keydown  按下按键不用弹起就触发    keyup    按下按键弹起才触发    1.Vue中常用的按键别名:        回车=&gt;enter        删除=&gt;delete(捕获“删除”和“退格”键)        退出=&gt; esc        空格=&gt;space        换行 =&gt; tab  (特殊，必须与keydown 去使用)        上=&gt; up        下 =&gt; down        左=&gt;left        右=&gt; right        2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case(短横线命名)        3.系统修饰键(用法特殊):ctrl alt shift meta            (1)配合keyup使用:按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。例如：ctrl+y ctrl+i....            (2)配合keydown使用:正常触发事件。        4.也可以使用keyCode去指定具体的按键(不推荐)        5.Vue.config.keyCodes.自定义键名=键码，可以去定制按键别名</code></pre><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性:"></a>计算属性:</h2><pre><code>    1.定义:要用的属性不存在，要通过已有属性计算得来。    2.原理:底层借助了Object.defineproperty方法提供的getter(get) 和setter(set)    3.get函数什么时候执行?        (1)初次读取时会执行一次。 有缓存        (2)当依赖的数据发生改变时会被再次调用。    4.优势:与methods实现相比，内部有缓存机制(复用)，效率更高，调试方便。    5.备注:        1.计算属性最终会出现在vm上，直接读取使用即可。        2.如果计算属性要被修改，那必须写set函数去响应修改。且set中要引起计算时依赖的数据发生改变。    6.可以简写，但是要先确定只读不改才可以简写</code></pre><h2 id="监视属性watch"><a href="#监视属性watch" class="headerlink" title="监视属性watch:"></a>监视属性watch:</h2><pre><code>        1.当被监视的属性变化时，回调函数自动调用，进行相关操作        2.监视的属性必须存在，才能进行监视!!        3.监视的两种写法:                (1)new Vue时传入watch配置                (2)通过vm.$watch监视        4.handler 什么时候调用？ 当上面的对象 发生改变时调用</code></pre><h3 id="深度监视"><a href="#深度监视" class="headerlink" title="深度监视:"></a>深度监视:</h3><pre><code>        (1).Vue中的watch默认不监测对象内部值的改变(一层)。        (2).配置deep:true可以监测对象内部值改变(多层)。    备注:        (1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以        (2).使用watch时根据数据的具体结构，决定是否采用深度监视。</code></pre><h2 id="computed-计算属性-和watch-监视属性-之间的区别"><a href="#computed-计算属性-和watch-监视属性-之间的区别" class="headerlink" title="computed(计算属性)和watch(监视属性)之间的区别:"></a>computed(计算属性)和watch(监视属性)之间的区别:</h2><pre><code>    1.computed能完成的功能，watch都可以完成。    2.watch能完成的功能，computed不一定能完成，例如:watch可以进行异步操作。两个重要的小原则:    1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm或组件实例对象。    2.所有不被Vue所管理的函数(定时器的回调函数、ajax的回调函数等 Promise的回调函数)，最好写成箭头函数        这样this的指向才是vm或组件实例对象。</code></pre><h2 id="绑定样式"><a href="#绑定样式" class="headerlink" title="绑定样式:"></a>绑定样式:</h2><pre><code>    1.class样式        写法:class=&quot;xxx&quot;xxx可以是字符串、对象、数组。            字符串写法适用于:类名不确定，要动态获取。            对象写法适用于:要绑定多个样式，个数不确定，名字也不确定。            数组写法适用于:要绑定多个样式，个数确定，名字也确定，但不确定用不用。    2.style样式        :style=&quot;&#123;fontSize: xxx&#125;&quot;其中xxx是动态值。        :style=&quot;[a,b]&quot;其中a、b是样式对象。</code></pre><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染:"></a>条件渲染:</h2><pre><code>    1.v-if        写法:        (1).v-if=&quot;表达式&quot;        (2).v-else-if=&quot;表达式&quot;        (3).v-else=&quot;表达式&quot;    适用于:切换频率较低的场景。    特点:不展示的DOM元素直接被移除。    注意:v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”        如果紧挨着的元素都要使用v-if 为了防止代码重写，        只需要这些把判断语句(v-if)放到一个template里面，把所有需要次判断的放里面        v-if 与 template配合使用     template 最大的特点是不影响结构    2.v-show        写法:v-show=&quot;表达式&quot;        适用于:切换频率较高的场景。        特点:不展示的DOM元素未被移除，仅仅是使用样式隐藏掉    3.备注:使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。</code></pre><h2 id="V-for指令"><a href="#V-for指令" class="headerlink" title="V-for指令:"></a>V-for指令:</h2><pre><code>    1.用于展示列表数据    2.语法:v-for=&quot;(item,index) in xxx&quot;:key=&quot;yyy&quot;    3.可遍历:数组(用的多)、对象、字符串(用的很少)、指定次数(用的很少)</code></pre><h2 id="面试题-react、vue中的key有什么作用-key的内部原理"><a href="#面试题-react、vue中的key有什么作用-key的内部原理" class="headerlink" title="面试题:react、vue中的key有什么作用?(key的内部原理)"></a>面试题:react、vue中的key有什么作用?(key的内部原理)</h2><pre><code>    1.虚拟DOM中key的作用:        key是虚拟DOM对象的标识，当数据发生变化时。Vue会根据【新数据】生成【新的虚拟DOM】，        随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下:    2.对比规则:        (1)旧虚拟DOM中找到了与新虚拟DOM相同的key:            ①.若虚拟DOM中内容没变，直接使用之前的真实DOM!            ②.若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM。        (2)旧虚拟DOM中未找到与新虚拟DOM相同的key            创建新的真实DOM，随后渲染到到页面。    3、用index作为key可能会引发的问题:        1.若对数据进行:逆序添加、逆序剧除等破坏顺序操作:            会产生没有必要的真实DOM更新==&gt;界面效果没问题，但效率低。        2.如果结构中还包含输入类的DOM:            会产生错误DOM更新==界面有问题。    4.开发中如何选择key?:        1.最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等 唯一值。        2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，            使用index作为kev是没有问题的。</code></pre><h2 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h2><pre><code>Vue监视数据的原理:    1.vue会监视data中所有层次的数据。    2.如何监测对象中的数据?        通过setter(set)实现监视，且要在new Vue时就传入要监测的数据。            (1)对象中后追加的属性，Vue默认不做响应式处理            (2).如需给后添加的属性做响应式，请使用如下API:                Vue.set(target,propertyName/index , value)              或                vm.$set(target，propertyName/index , value    3.如何监测数组中的数据?        通过包裹数组更新元素的方法实现，本质就是做了两件事:            (1).调用原生对应的方法对数组进行更新。            (2)。重新解析模板，进而更新页面。    4.在Vue修改数组中的某个元素一定要用如下方法:        1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()        2.Vue.set()或vm.$set特别注意:Vue.set()和vm.$set()不能给vm或vm的根数据对象添加属性!!! eg:  Vue.set(vm._data...)</code></pre><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器:"></a>过滤器:</h2><pre><code>    定义:对要显示的数据进行特定格式化后再显示(适用于一些简单逻辑的处理)。    语法:        1.注册过滤器:Vue.filter(name,callback) 或 new Vue&#123;filters:&#123;&#125;&#125;        2.使用过滤器:&#123;&#123;xxx | 过滤器名&#125;&#125; 或 v-bind;属性=&quot;xxx | 过滤器名&quot;    备注:        1.过滤器也可以接收额外参数、多个过滤器也可以串联        2.并没有改变原本的数据，是产生新的对应的数据</code></pre><h2 id="学过的指令（内置指令）"><a href="#学过的指令（内置指令）" class="headerlink" title="学过的指令（内置指令）:"></a>学过的指令（内置指令）:</h2><pre><code>    v-bind :  单向绑定解析表达式，可简写为:xxX    v-model:  双向数据绑定    v-for :   遍历数组/对象/字符串    V-on :    绑定事件监听，可简写为@    v-if :    条件渲染(动态控制节点是否存存在)    v-else :  条件渲染(动态控制节点是否存存在)    v-show :  条件渲染(动态控制节点是否展示)    v-text指令:        1作用: 向其所在的节点中渲染文本内容。        2.与插值语法的区别: v-text会替换掉节点中的内容，&#123;&#123;xx&#125;&#125;则不会。</code></pre><h2 id="v-html指令"><a href="#v-html指令" class="headerlink" title="v-html指令:"></a>v-html指令:</h2><pre><code>        1.作用:向指定节点中渲染包含html结构的内容。        2.与插值语法的区别:            (1).v-html会替换掉节点中所有的内容，&#123;&#123;xx&#125;&#125;则不会。            (2).v-html可以识别html结构。        3.严重注意:v-html有安全性问题!!!!            (1)在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。            (2)一定要在可信的内容上使用v-html，永不要用在用户提交的内容上!</code></pre><h3 id="v-cloak指令-没有值"><a href="#v-cloak指令-没有值" class="headerlink" title="v-cloak指令(没有值):"></a>v-cloak指令(没有值):</h3><pre><code>        1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。        2.使用css配合v-cloak可以解决网速慢时页面展示出&#123;&#123;xxx&#125;&#125;的问题。</code></pre><h3 id="v-once指令"><a href="#v-once指令" class="headerlink" title="v-once指令:"></a>v-once指令:</h3><pre><code>        1.v-once所在节点在初次动态渲染后，就视为静态内容了。        2.以后数据的改变不会引起 v-once 所在结构的更新，可以用于优化性能。</code></pre><h3 id="v-pre指令"><a href="#v-pre指令" class="headerlink" title="v-pre指令:"></a>v-pre指令:</h3><pre><code>        1.跳过其所在节点的编译过程。        2.可利用它跳过:没有使用指令语法、没有使用插值语法的节点，会加快编译。</code></pre><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><pre><code>自定义指令总结:    一、定义语法:        (1).局部指令:            new Vue(&#123;                       new Vue(&#123;            directives:&#123;指令名:配置对象&#125;   或       directives()&#123;指令名:回调函数&#125;            &#125;)                                      &#125;)        (2).全局指令:            Vue.directive(指令名，配置对象)            或  Vue.directive(指令名，回调函数)    二、配置对象中常用的3个回调:        (1)bind:指令与元素成功绑定时调用。        (2)inserted:指令所在元素被插入页面时调用。        (3).update:指令所在模板结构被重新解析时调用。    三、备注:        1.指令定义时不加v-，但使用时要加v-;        2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。    例如: kebab-case : user-name     camelCase: userName</code></pre><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期:"></a>生命周期:</h2><pre><code>        1.又名:生命周期回调函数、生命周期函数、生命周期钩子。        2.是什么: Vue在关键时刻带我们调用的一些特殊名称的函数。        3.生命周期数的名字不可更改，但是的具体内容是程序员根据需求编写的。        4.生命周期函数中的this指向是vm 或 组件实例对象。</code></pre><h2 id="生命周期四大阶段："><a href="#生命周期四大阶段：" class="headerlink" title="生命周期四大阶段："></a>生命周期四大阶段：</h2><pre><code>    1.初始化阶段:    beforeCreate：实例刚创建完成,此时还没有data和methods属性    created：vue实例data和method属性已经初始化完成,此时还没有编译模板    2.实例挂载阶段    beforeMount：挂载前 模板编译完成,此时el 还没有挂载 , el还没有挂载，data目前可见    mounted：挂载完成后 模板编译完成,$el挂载完成 ***    3.数据更新阶段    beforeUpdate： 数据更新时执行,data数据此时已经是最新的数据,UI界面还是旧的    updated：数据更新完成后,界面和data里的数据此时都是最新的,完成的界面的更新渲染render    4.销毁阶段    销毁前: beforeDestroy： 实例准备销毁,此时data和methods方法都能用 ***    销毁后:destroyed： 实例销毁完成,此时原先创建的实例方法和属性都不可以添加属性</code></pre><h3 id="常用的生命周期钩子"><a href="#常用的生命周期钩子" class="headerlink" title="常用的生命周期钩子:"></a>常用的生命周期钩子:</h3><pre><code>    1.mounted:挂载完成后   发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。    2.beforeDestroy:销毁前  清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。关于销毁Vue实例    1.销毁后借助Vue开发者工具看不到任何信息。    2.销毁后自定义事件会失效，但原生DOM事件依然有效。    3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</code></pre><h2 id="Vue中使用组件的三大步骤"><a href="#Vue中使用组件的三大步骤" class="headerlink" title="Vue中使用组件的三大步骤:"></a>Vue中使用组件的三大步骤:</h2><pre><code>    一、定义组件(创建组件)    二、注册组件    三、使用组件(写组件标签)一、如何定义一个组件?    使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别    区别如下:        1.el不要写!!，为什么? ——  最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。        2.data必须写成函数，为什么? --- 避免组件被复用时，数据存在引用关系。    备注: 使用template可以配置组件结构。二、如何注册组件?    1.局部注册:靠new Vue的时候传入components选项    2.全局注册:靠Vue.component(组件名，组件)三、编写组件标签:    例如：先创建School组件，才在body中输出 &lt;school&gt;&lt;/school&gt;</code></pre><h2 id="几个注意点"><a href="#几个注意点" class="headerlink" title="几个注意点:"></a>几个注意点:</h2><pre><code>    1.关于组件名:        单个单词组成:            第一种写法(首字母小写):school            第二种写法(首字母大写):School        多个单词组成:            第一种写法(kebab-case命名):my-school            第二种写法(CamelCase命名):MySchool(需要Vue脚手架支持)        备注:            (1).组件名尽可能回避HTML中已有的元素名称，例如:h2 H2都不行。            (2).可以使用 name 配置项指定组件在 开发者工具 中&#39;呈现&#39;的名字。    2.关于组件标签:        第一种写法:&lt;school&gt;&lt;/school&gt;        第二种写法:&lt;school/&gt;        备注:不用使用脚手架时，&lt;school/&gt;会导致后续组件不能渲染。    3.一个简写方式:        const school = Vue.extend(options)        可简写为:const school = options</code></pre><h2 id="关于VueComponent"><a href="#关于VueComponent" class="headerlink" title="关于VueComponent:"></a>关于VueComponent:</h2><pre><code>    1.school组件 本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。    2.我们只需要写&lt;school/&gt;或&lt;school&gt;&lt;/school&gt;，Vue解析时会帮我们创建school组件的实例对象，        即Vue帮我们执行的:new VueComponent(options)。    3.特别注意:每次调用Vue.extend，返回的都是一个全新的VueComponent!!!!    4.关于this指向:        (1).组件配置中:            data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】        (2).new Vue()配置中:            data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。   5.VueComponent的实例对象，以后简称vc(也可称之为:组件实例对象)。        Vue的实例对象，以后简称vm。</code></pre><h3 id="一个重要的内置关系"><a href="#一个重要的内置关系" class="headerlink" title="一个重要的内置关系"></a>一个重要的内置关系</h3><pre><code>1.一个重要的内置关系:VueComponent.prototype.__proto__ === Vue.prototype2.为什么要有这个关系:让组件实例对象 VueComponent(vc) 可以访问到Vue原型上的属性、方法。</code></pre>]]></content>
    
    
    <summary type="html">Vue2自己总结的初级知识点</summary>
    
    
    
    <category term="前端" scheme="https://lcl.shiqi217.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Vue" scheme="https://lcl.shiqi217.com/tags/Vue/"/>
    
  </entry>
  
</feed>
